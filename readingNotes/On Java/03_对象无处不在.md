# 3.对象无处不在

- [3.对象无处不在](#3对象无处不在)
  - [3.1. 通过引用操作对象](#31-通过引用操作对象)
  - [3.2. 必须创建所有对象](#32-必须创建所有对象)
    - [3.2.1. 数据保存在哪里](#321-数据保存在哪里)
    - [3.2.2. 特殊情况：基本类型](#322-特殊情况基本类型)
    - [3.2.3. Java中的数组](#323-java中的数组)
  - [3.3. 注释](#33-注释)
  - [3.4. 无须销毁对象](#34-无须销毁对象)
    - [3.4.1 作用域](#341-作用域)
    - [3.4.2 对象的作用域](#342-对象的作用域)
  - [3.5. 使用 class 关键字创建新类型](#35-使用-class-关键字创建新类型)
  - [3.6. 方法、参数以及返回值](#36-方法参数以及返回值)
  - [3.7. 编写Java程序](#37-编写java程序)
    - [3.7.1. 名称可见性](#371-名称可见性)
    - [3.7.2. 使用其他组件](#372-使用其他组件)
    - [3.7.3. static关键字](#373-static关键字)

## 3.1. 通过引用操作对象

- 通过使用统一的语法，Java将一切都视为对象；
- 虽然说的是“将一切都视为对象”，但你实际操作的其实是该对象的`引用（reference）`;
- 引用未必会关联某个对象,例如：`String s;` 不过，这样只是创建了一个引用而非对象。如果现在像对象s发送信息，则会得到一条报错信息：`NullPointerException`；安全的做法是，在创建引用的时候就进行初始化；

## 3.2. 必须创建所有对象

- 引用的作用是关联对象。通常我们使用`new`关键字来创建对象。`new`关键字表达的意思是 *“我要一个这种类型的对象”*。

### 3.2.1. 数据保存在哪里

5种数据存储方式：

1. `寄存器（register）`。这是速度最快的数据存储方式，因为它保存数据的位置不同于其他方式：数据会直接保存在`中央处理器（CPU）`里。然而寄存器的数量是有限的，所以只能按需分配。此外，你不能直接控制寄存器的分配，甚至你在程序中找不到寄存器存在过的证据。

2. `栈（stack）`。数据存储在`随机存储器（RAM）`里，处理器可以通过`栈指针（stack pointer）`直接操作该数据。具体来说，栈指针向下移动将申请一款新的内存，向上移动则会释放这块内存。这是一种极其迅速和高效的内存分配方式，其效率仅次于寄存器。只不过Java系统在创建应用程序时就必须明确栈上所有对象的生命周期。这种限制约束了程序的灵活性，因此虽然有一些数据会保存在栈上（尤其是对象引用），对象本身却并非如此。

3. `堆（heap）`。这是一个通用的内存池（使用的也是RAM空间），用于存放所有Java对象。与栈不同的是，编译器并不关心位于堆上的对象需要存在多久。因此，堆堆使用是非常灵活的。比如，当你需要一个对象时，可以随时使用new来创建这个对象，那么当这段代码被执行时，Java会在堆上为该对象分配内存空间。然而这种灵活性是有代价的：分配和清理堆存储要比栈存储花费更多的时间。好消息是，随着时间的推移，Java的堆内存分配机制已经变得非常高效了，所以并不需要太过关注此类问题。

4. `常量存储（constant storage）`。常量通常会直接保存在程序代码中，因为它们的值不会改变，所以这样做是安全的。有时候常量会与其他代码隔离开来，于是在某些嵌入式系统里，这些常量就可以保存在`只读存储器（ROM）`中。

5. `非RAM存储（non-RAM storage）`。如果一段数据没有保存在应用程序里，那么该数据的生命周期即不依赖于应用程序是否运行，也不受应用程序的管制。其中最典型的例子之一是`“序列化对象”（serialized object）`，它指的是转换字节流（叫作“序列化”）并可以发送至其他机器的对象。另一个例子则是`“持久化对象”（persistent object）`，它指的是保存在磁盘上的对象，而这些对象即便在程序结束运行之后也依然能够保持其状态。这些数据存储类型的特点在于，它们会将对象转换成其他形式以保存于其他媒介中，然后在需要的时候重新转换回常规的RAM对象。Java支持轻量级的持久化对象存储。

### 3.2.2. 特殊情况：基本类型

有一些经常使用的类型享受特殊待遇，可以将它们称为`“基本类型”（primitive type）`。它们之所以享受特别待遇，是因为new关键字是在堆上创建对象，这就意味着哪怕是创建一些简单的变量也不会很高效。对于基本类型，Java使用了与C以及C++相同的实现机制，这意味着唯美无须使用new来创建基本类型的变量，而是直接创建一个`“自动变量”（automatic variable）`，注意**不是引用**。也就是说，该变量会直接在`栈`上保存它的值，因此运行效率也较高。

- 基本类型：
  | 基本类型 | 大小 | 最小值           | 最大值       | 包装类    |
  | -------- | ---- | ---------------- | ------------ | --------- |
  | boolean  | -    | -                | -            | Boolean   |
  | char     | 16位 | Unicode 0 \u0000 | 65535 \uffff | Character |
  | byte     | 8位  | $-128$           | $+127$       | Byte      |
  | short    | 16位 | $-32768$         | $+32767$     | Short     |
  | int      | 32位 | $-2^{31}$        | $+2^{31}-1$  | Integer   |
  | long     | 64位 | $-2^{63}$        | $+2^{63}-1$  | Long      |
  | float    | 32位 | IEEE754          | IEEE754      | Float     |
  | double   | 64位 | IEEE754          | IEEE754      | Double    |
  | void     | -    | -                | -            | Void      |

- boolean类型的空间大小没有明确标出，其对象只能被赋予为`true`或`false`。

- 此外，Java还为基本类型提供了对应的`“包装类”（wrapper class）`，通过包装类可以将基本类型呈现为于堆上的非原始对象。而`“自动装箱”（autoboxing）`机制能够将基本类型对象自动转换为包装类对象。

- 高进度数字。Java提供了两个支持高精度计算的类，分别是`BigInteger`和`BigDecimal`。

### 3.2.3. Java中的数组

- Java的数组一定会被初始化，并且无法访问数组边界之外的元素。这种边界检查的代价是需要消耗少许内存，以及运行时需要少量时间来验证索引的正确性。

- 当你创建一个用于放置对象的数组时，实际上数组里包含的是引用，而这些引用会被自动除时候为一个特殊的值：null。Java会认为一个值为null的引用没有指向任何对象，所以当你操作引用之前，需要确保将其指向里某个对象。如果你试图操作一个值为null的引用，系统会返回一个运行时报错。

## 3.3. 注释

- Java支持两种类型注释：

  - 多行注释：`\* 注释内容，可以多行 *\`；
  - 单行注释：`\\ 注释内容`;

## 3.4. 无须销毁对象

### 3.4.1 作用域

- Java的作用域范围都是通过大括号(`{}`)来定义的。例如：

  ``` java
  {
    int x = 12;
    // 只有变量x可见
    {
      int q = 96;
      // 变量x和q都可见
    }
    // 只有变量x可见
    // 超出了变量q的作用域
  }
  ```

- 在作用域里定义的变量只在该作用域的范围内可见。

### 3.4.2 对象的作用域

- Java对象的生命周期和基本类型有所不同。当使用`new`创建一个对象时，该对象在其作用域结束后会依然存在。例如：

  ``` java
  {
    String s = new String("a string");
  } // 作用域结束
  ```

- 虽然引用s会在作用域结束后消失，但是它指向的String 对象还会继续占用内存。对于上面的代码而言，该String对象在作用域结束后就无法再获取，这是因为已经超出了气唯一引用的作用域范围。

- 如果Java对象堆这些对象不闻不问，为什么应用程序并没有因为内存溢出而强行结束呢？原因是，Java使用了`垃圾收集器`监听所有通过new创建的对象，并及时发现哪些对象不再被引用，然后它会释放这些对象所占用的内存。

## 3.5. 使用 class 关键字创建新类型

大多数面向对象编程语言会使用 `class` 关键字来描述新的对象种类。其用法是 class 关键字后面跟着新的类名：

  ```java
  class ATypeName{
    // 类的具体实现放在这里
  }  
  ```

- 字段：
  - 当定义一个类时，你可以为其定义两种元素：`字段（有时叫作 “数据成员”）`和`方法（有时叫作 “成员函数”）`。
  - 我们可以通过对象的引用与字段进行交互。
  - 字段可以是任何类型对象，也可以时基本类型。

- 基本类型的默认值。当一个类的字段是基本类型时，即便没有初始化这些字段，它们也会拥有默认值。如下表：
  | 基本类型 | 默认值       |
  | -------- | ------------ |
  | boolean  | false        |
  | char     | \u0000(null) |
  | byte     | (byte)0      |
  | short    | (short)0     |
  | int      | 0            |
  | long     | 0l           |
  | float    | 0.0f         |
  | double   | 0.0          |

  - 当变量作为类成员存在时，Java才会将其初始化为以上的默认值。确保了基本类型的字段一定会被初始化。 `不过对于编写的程序而言，这些默认值可能并不是正确或合理的值，所以最佳实践应该是显示地初始化这些变量`。
  - 这种机制并不会用于`局部变量（local variable）`，因为局部变量并不是类的字段。

## 3.6. 方法、参数以及返回值

- 在Java中，我们称之为`“方法”（method）`，意思是“做某件事的方式”;
- 方法的组成部分：方法名、参数、返回值，以及方法体（method body）;

  ``` java
  ReturnType methodName (/*参数列表*/){
    // method body
  }
  ```

- ReturnType 表示当调用一个方法时，该方法生成的值时什么类型的；
- 参数列表提供了一系列需要传递给方法的信息，包括信息的类型和名称。
- **方法名称和参数列表共同构成了方法的“签名”（signature），方法签名即该方法的唯一标识**；
- 参数列表描述了需要传递给方法的信息；
- return 关键字做了两件事：
  1. 告诉我们`从方法中离开吧，一切结束了`；
  2. 当该方法生成了一个值当时候，将这个值放置于return之后。
- 可以返回任意类型的值，但是如果不返回任何值，就表示该方法生成的值为`void（意思是什么都没有）`；
- 当返回值当类型是`void`时，使用`return`关键字都作用时退出该方法，因此在方法的末尾处就没有必要使用`return`了。

## 3.7. 编写Java程序

### 3.7.1. 名称可见性

- 所有的编程语言都有一个问题，那就是对名称的控制。Java通过一个新颖的方法解决了此问题。为了能够清晰地描述库的名称，Java语言的设计者所使用的方法就是将互联网域名反转使用。因为域名是唯一的，所以一定不会冲突。举例，如果域名是`ituring.com`，那么`foibles`库的名称就是`com.ituring.foibles`。而反转的域名之后的几个`"."`实际上描述了*子目录的结构*。

### 3.7.2. 使用其他组件

- 当在程序中使用预定于的类时，编译器必须找到这个类。利用`import`关键字告知Java编译器你想要使用哪个类。
- `import`语句的作用是通知编译器导入指定位置的包，即放置各种类的库。
  
  ```java
  import java.util.ArrayList;
  import java.util.*;
  ```

### 3.7.3. static关键字

- static关键字解决了两个问题：
  1. 有时候我们需要一小块共享空间来保存某个特定的字段，而且并不关心创建多少个对象，甚至有么有创建对象；
  2. 你需要使用一个类的某个方法，而该方法和具体的对象无关；换句话说，你希望即便没有生成任何该类的对象，依然可以调用其方法。


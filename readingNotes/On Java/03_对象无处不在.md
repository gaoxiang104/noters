# 3.对象无处不在

- [3.对象无处不在](#3对象无处不在)
  - [3.1. 通过引用操作对象](#31-通过引用操作对象)
  - [3.2. 必须创建所有对象](#32-必须创建所有对象)
    - [3.2.1. 数据保存在哪里](#321-数据保存在哪里)
    - [3.2.2. 特殊情况：基本类型](#322-特殊情况基本类型)
    - [3.2.3. Java中的数组](#323-java中的数组)
  - [3.3. 注释](#33-注释)
  - [3.4. 无须销毁对象](#34-无须销毁对象)

## 3.1. 通过引用操作对象

- 通过使用统一的语法，Java将一切都视为对象；
- 虽然说的是“将一切都视为对象”，但你实际操作的其实是该对象的`引用（reference）`;
- 引用未必会关联某个对象,例如：`String s;` 不过，这样只是创建了一个引用而非对象。如果现在像对象s发送信息，则会得到一条报错信息：`NullPointerException`；安全的做法是，在创建引用的时候就进行初始化；

## 3.2. 必须创建所有对象

- 引用的作用是关联对象。通常我们使用`new`关键字来创建对象。`new`关键字表达的意思是 *“我要一个这种类型的对象”*。

### 3.2.1. 数据保存在哪里

5种数据存储方式：

1. `寄存器（register）`。这是速度最快的数据存储方式，因为它保存数据的位置不同于其他方式：数据会直接保存在`中央处理器（CPU）`里。然而寄存器的数量是有限的，所以只能按需分配。此外，你不能直接控制寄存器的分配，甚至你在程序中找不到寄存器存在过的证据。

2. `栈（stack）`。数据存储在`随机存储器（RAM）`里，处理器可以通过`栈指针（stack pointer）`直接操作该数据。具体来说，栈指针向下移动将申请一款新的内存，向上移动则会释放这块内存。这是一种极其迅速和高效的内存分配方式，其效率仅次于寄存器。只不过Java系统在创建应用程序时就必须明确栈上所有对象的生命周期。这种限制约束了程序的灵活性，因此虽然有一些数据会保存在栈上（尤其是对象引用），对象本身却并非如此。

3. `堆（heap）`。这是一个通用的内存池（使用的也是RAM空间），用于存放所有Java对象。与栈不同的是，编译器并不关心位于堆上的对象需要存在多久。因此，堆堆使用是非常灵活的。比如，当你需要一个对象时，可以随时使用new来创建这个对象，那么当这段代码被执行时，Java会在堆上为该对象分配内存空间。然而这种灵活性是有代价的：分配和清理堆存储要比栈存储花费更多的时间。好消息是，随着时间的推移，Java的堆内存分配机制已经变得非常高效了，所以并不需要太过关注此类问题。

4. `常量存储（constant storage）`。常量通常会直接保存在程序代码中，因为它们的值不会改变，所以这样做是安全的。有时候常量会与其他代码隔离开来，于是在某些嵌入式系统里，这些常量就可以保存在`只读存储器（ROM）`中。

5. `非RAM存储（non-RAM storage）`。如果一段数据没有保存在应用程序里，那么该数据的生命周期即不依赖于应用程序是否运行，也不受应用程序的管制。其中最典型的例子之一是`“序列化对象”（serialized object）`，它指的是转换字节流（叫作“序列化”）并可以发送至其他机器的对象。另一个例子则是`“持久化对象”（persistent object）`，它指的是保存在磁盘上的对象，而这些对象即便在程序结束运行之后也依然能够保持其状态。这些数据存储类型的特点在于，它们会将对象转换成其他形式以保存于其他媒介中，然后在需要的时候重新转换回常规的RAM对象。Java支持轻量级的持久化对象存储。

### 3.2.2. 特殊情况：基本类型

有一些经常使用的类型享受特殊待遇，可以将它们称为`“基本类型”（primitive type）`。它们之所以享受特别待遇，是因为new关键字是在堆上创建对象，这就意味着哪怕是创建一些简单的变量也不会很高效。对于基本类型，Java使用了与C以及C++相同的实现机制，这意味着唯美无须使用new来创建基本类型的变量，而是直接创建一个`“自动变量”（automatic variable）`，注意**不是引用**。也就是说，该变量会直接在栈上保持它的值，因此运行效率也较高。

- 基本类型：
  | 基本类型 | 大小 | 最小值           | 最大值       | 包装类    |
  | -------- | ---- | ---------------- | ------------ | --------- |
  | boolean  | -    | -                | -            | Boolean   |
  | char     | 16位 | Unicode 0 \u0000 | 65535 \uffff | Character |
  | byte     | 8位  | $-128$           | $+127$       | Byte      |
  | short    | 16位 | $-32768$         | $+32767$     | Short     |
  | int      | 32位 | $-2^{31}$        | $+2^{31}-1$  | Integer   |
  | long     | 64位 | $-2^{63}$        | $+2^{63}-1$  | Long      |
  | float    | 32位 | IEEE754          | IEEE754      | Float     |
  | double   | 64位 | IEEE754          | IEEE754      | Double    |
  | void     | -    | -                | -            | Void      |

- boolean类型的空间大小没有明确标出，其对象只能被赋予为`true`或`false`。

- 此外，Java还为基本类型提供了对应的`“包装类”（wrapper class）`，通过包装类可以将基本类型呈现为于堆上的非原始对象。而`“自动装箱”（autoboxing）`机制能够将基本类型对象自动转换为包装类对象。

- 高进度数字。Java提供了两个支持高精度计算的类，分别是`BigInteger`和`BigDecimal`。

### 3.2.3. Java中的数组

- Java的数组一定会被初始化，并且无法访问数组边界之外的元素。这种边界检查的代价是需要消耗少许内存，以及运行时需要少量时间来验证索引的正确性。

- 当你创建一个用于放置对象的数组时，实际上数组里包含的是引用，而这些引用会被自动除时候为一个特殊的值：null。Java会认为一个值为null的引用没有指向任何对象，所以当你操作引用之前，需要确保将其指向里某个对象。如果你试图操作一个值为null的引用，系统会返回一个运行时报错。

## 3.3. 注释

- Java支持两种类型注释：

  - 多行注释：`\* 注释内容，可以多行 *\`；
  - 单行注释：`\\ 注释内容`;

## 3.4. 无须销毁对象


# 12. 集合

- [12. 集合](#12-集合)
  - [12.0. 引言](#120-引言)
  - [12.1. 泛型和类型安全的集合](#121-泛型和类型安全的集合)
    - [12.1.1. 新特性：类型推断和泛型](#1211-新特性类型推断和泛型)

## 12.0. 引言

- 数组是持有一组对象的最高效的方式，而且要持有一组基本类型数据的话，数组也是不二之选。但是，数组的大小是固定的。更常见的情况是，在编程的时候我们并不知道需要多少个对象，或者我们需要更高级的方式来保存对象，因此大小固定这一点就很有局限性了。

- `java.util` 库有相当完整的一组`集合类（collection class）`来解决这个问题，其中基本的类型是 `List`、`Set`、`Queue` 和 `Map` 。这些类型也叫作 `容器类（container class）`。集合类提供了一些持有对象的高级方法，并解决了相当多的问题。

- 不同的集合类有不同的特性，比如 `Set` 对于值相同的对象只会保存一个，而 `Map` 是一个关联数组，可以将对象和其他对象关联起来。*<u>除了这些独特之处，Java 集合类还有一大共性，那就是都可以自动调整大小。因此，和数组不同的是，我们可以再集合类中放入任意多个对象，而不用担心它应该是多大。</u>*

## 12.1. 泛型和类型安全的集合

- 使用 `Java 5` 之前的集合类，问题之一是编译器允许向集合中插入不正确的类型。
- 借助`泛型`，*<u>就可以再**编译时**防止将错误类型的对象加入某个集合中</u>*。

``` java
public static void main(String[] args) {
    ArrayList<Apple> apples = new ArrayList<>();
    for (int i = 0; i < 3; i++) {
        apples.add(new Apple());
    }
    // 编译时错误
    // apples.add(new Orange());
    for (Apple apple : apples){
        System.out.println(apple.id());
    }
}
```

- 定义在 `apples` 的表达式的右侧，出现了 `new ArrayList<>()` 。因为有钻石形状的 <> 符号，所以它有时也叫作 “钻石语法”。在 Java 7 之前，我们事实上必须在表达式的两侧重复写出类型声明，就像这样： `ArrayList<Apple> apples = new ArrayList<Apple>();` ;

- 当指定了某种类型作为泛型参数时，我们并不是只能放入该类型的对象。在泛型的情况下，向上转型也可以像其他类型中那样起作用；

### 12.1.1. 新特性：类型推断和泛型

- 第6章引入了 “`局部变量类型推断（var 的使用）`” 一节，这是 JDK 10/11 加入的特性。方便的是，这个特性也可以用来简化涉及泛型的定义。

``` java

// {NewFeature} 从 JDK 11 开始
public class GenericTypeInference {
    void old(){
        ArrayList<Apple> apples = new ArrayList<Apple>();
    }
    void modern(){
        var apples = new ArrayList<Apple>();
    }
    void pitFall (){ // 坑
        var apples = new ArrayList<>();
        apples.add(new Apple());
        apples.get(0); // 作为普通的 Object 类型返回
    }
}
```

- 注意， `modern()` 中定义右侧的钻石语法（`<>`）被显示的 `<Apple>` 替换掉了，这样编译器就有足够的信息来执行类型推断了。

- 替换现有代码中的钻石语法，在某些地方可能产生一个问题，就像在 `pitFall()` 中看到的那样。直接用 `pitFall()` 中的 `var` 替换 `old()` 中左侧的 `ArrayList<Apple>`，可以成功编译。`<>` 变成了 `<Object>` ，这不是我们想要的，但是编译器没有报错。
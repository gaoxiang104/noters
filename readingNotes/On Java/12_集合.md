# 12. 集合

- [12. 集合](#12-集合)
  - [12.0. 引言](#120-引言)
  - [12.1. 泛型和类型安全的集合](#121-泛型和类型安全的集合)
    - [12.1.1. 新特性：类型推断和泛型](#1211-新特性类型推断和泛型)
  - [12.2. 基本概念](#122-基本概念)
  - [12.3. 添加一组元素](#123-添加一组元素)
  - [12.4. 打印集合](#124-打印集合)
  - [12.5. List](#125-list)
  - [12.6. Iterator](#126-iterator)
    - [12.6.1. Iterable](#1261-iterable)
    - [12.6.2. ListIterator](#1262-listiterator)
  - [12.7. LinkedList](#127-linkedlist)
  - [12.8. Stack](#128-stack)
  - [12.9. Set](#129-set)
  - [12.10. Map](#1210-map)
  - [总结](#总结)

## 12.0. 引言

- 数组是持有一组对象的最高效的方式，而且要持有一组基本类型数据的话，数组也是不二之选。但是，数组的大小是固定的。更常见的情况是，在编程的时候我们并不知道需要多少个对象，或者我们需要更高级的方式来保存对象，因此大小固定这一点就很有局限性了。

- `java.util` 库有相当完整的一组`集合类（collection class）`来解决这个问题，其中基本的类型是 `List`、`Set`、`Queue` 和 `Map` 。这些类型也叫作 `容器类（container class）`。集合类提供了一些持有对象的高级方法，并解决了相当多的问题。

- 不同的集合类有不同的特性，比如 `Set` 对于值相同的对象只会保存一个，而 `Map` 是一个关联数组，可以将对象和其他对象关联起来。*<u>除了这些独特之处，Java 集合类还有一大共性，那就是都可以自动调整大小。因此，和数组不同的是，我们可以再集合类中放入任意多个对象，而不用担心它应该是多大。</u>*

## 12.1. 泛型和类型安全的集合

- 使用 `Java 5` 之前的集合类，问题之一是编译器允许向集合中插入不正确的类型。
- 借助`泛型`，*<u>就可以再**编译时**防止将错误类型的对象加入某个集合中</u>*。

``` java
public static void main(String[] args) {
    ArrayList<Apple> apples = new ArrayList<>();
    for (int i = 0; i < 3; i++) {
        apples.add(new Apple());
    }
    // 编译时错误
    // apples.add(new Orange());
    for (Apple apple : apples){
        System.out.println(apple.id());
    }
}
```

- 定义在 `apples` 的表达式的右侧，出现了 `new ArrayList<>()` 。因为有钻石形状的 <> 符号，所以它有时也叫作 “钻石语法”。在 Java 7 之前，我们事实上必须在表达式的两侧重复写出类型声明，就像这样： `ArrayList<Apple> apples = new ArrayList<Apple>();` ;

- 当指定了某种类型作为泛型参数时，我们并不是只能放入该类型的对象。在泛型的情况下，向上转型也可以像其他类型中那样起作用；

### 12.1.1. 新特性：类型推断和泛型

- 第6章引入了 “`局部变量类型推断（var 的使用）`” 一节，这是 JDK 10/11 加入的特性。方便的是，这个特性也可以用来简化涉及泛型的定义。

``` java

// {NewFeature} 从 JDK 11 开始
public class GenericTypeInference {
    void old(){
        ArrayList<Apple> apples = new ArrayList<Apple>();
    }
    void modern(){
        var apples = new ArrayList<Apple>();
    }
    void pitFall (){ // 坑
        var apples = new ArrayList<>();
        apples.add(new Apple());
        apples.get(0); // 作为普通的 Object 类型返回
    }
}
```

- 注意， `modern()` 中定义右侧的钻石语法（`<>`）被显示的 `<Apple>` 替换掉了，这样编译器就有足够的信息来执行类型推断了。

- 替换现有代码中的钻石语法，在某些地方可能产生一个问题，就像在 `pitFall()` 中看到的那样。直接用 `pitFall()` 中的 `var` 替换 `old()` 中左侧的 `ArrayList<Apple>`，可以成功编译。`<>` 变成了 `<Object>` ，这不是我们想要的，但是编译器没有报错。

## 12.2. 基本概念

- Java 集合类库是用来“持有对象”的，而且从设计上讲，它可以分为两个不同的概念，表示为库的两个基本接口。
  1. **`Colletion`**: 一个由单独元素组成的序列，而且这些元素要符合一条或多条规则。 `List` 必须按照元素插入顺序来保存他们； `Set` 中不能存在重复元素；而 `Queue` 则要按照**排队规则**来输出元素（通常与元素插入的顺序相同）。
  2. **`Map`**: 一组键值对像对，使用键来查找值。`ArrayList` 使用一个数值来查找某个对象，所以在某种意义上它将数值与对象关联在了一起。而 `Map` 使用**另一个对象**来查找某个对象。它也被称作**关联数组**，因为它将对象与其他对象关联在了一起；或者被称作字典，这是因为它使用一个键对象来查找一个值对象，就像我们在字典中使用一个单词来查找其定义一样。 `Map` 是非常强大的编程工具；

``` java
List<Apple> apples = new ArrayList<>();

List<Apple> apples = new LinkedList<>();
```

- **序列**是持有一组对象的一种方式，而 `Collection` 接口就是序列概念的一般化；

- `add()` 方法是要将一个新元素放入 `Collection` 中；

- `Set` 的含义：只有元素不存在的时候才会将其放入。而对于 `ArrayList` , 或者是任何一种 `List` ， `add()` 的含义总是“放进去”，因为 `List` 不会关心元素是不是有重复；

## 12.3. 添加一组元素

- `java.util` 中的 `Arrays` 和 `Collections` 类都包含了一些工具方法，用于向一个 `Collection` 中添加一组元素；
  - `Arrays.asList()` 方法可以接受一个数组，或者一个用逗号分隔的元素列表（使用可变参数），并将其转换为一个 `List` 对象。
  - `Collections.addAll()` 方法接受一个 `Collection` 对象、一个数组，或者一个用逗号分隔的列表，将其中所欲的元素都添加到这个 `Collection` 中。

``` java
// 向 Collection 对象中添加一组元素
public class AddingGroups {
    public static void main(String[] args) {
        Collection<Integer> collection =
                new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));
        Integer[] moreInts = {6, 7, 8, 9, 10};
        collection.addAll(Arrays.asList(moreInts));
        // 运行快很多，但是我们无法以这种方式构建 Collection
        Collections.addAll(collection, 11,12,13,14,15);
        Collections.addAll(collection,moreInts);
        // 生成一个底层为数组的列表
        List<Integer> list = Arrays.asList(16,17,18,19,20);
        list.set(1,99); // 修改元素
        // list.add(21); // 运行时错误；底层的数组不能调整大学

    }
}
```

> 注意：`Arrays.asList()` 的输出，将其当做一个 `List`，但它的底层实现用的数组，大小无法调整。<u>底层使用了 `内部类` ，创建了一个私有的 `ArrayList`来实现 `List` ，参考下面的代码片段截图</u>：

![12-Code-1](./imgs/12-Code-1.png)

## 12.4. 打印集合

- 我们必须使用 `Arrays.toString()` 来作为`数组`生成可以打印的表示，但是集合类不需要任何帮助，就能很漂亮地完成打印。

- `ArrayList` 和 `LinkedList` 都是 `List` 类型，都是以插入顺序保存元素的。两者的不同之处是对于特定类型的操作在性能上有差别，而且 `LinkedList` 包含的操作也多于 `ArrayList` ；

- `HashSet`、`TreeSet` 和 `LinkedHashSet` 都是 `Set` 类型。对于相同的条目 `Set` 只会保存一个，而且不同的 `Set` 实现会以不同方式保存元素。 `HashSet` 使用了一种相当复杂的方式存储元素，这种技术是检索元素最快的方式，因此存储顺序看起来没有实际意义（我们往往只关心某个元素是不是 `Set` 的成员，顺序并不重要）。如果存储顺序非常重要，可以使用 `TreeSet` ，它会升序保存对象；或使用 `LinkedHashSet` ，它会按照添加顺序来保存对象。

- `Map（也称作关联数组）`使用**键**来查找对象，就像一个简单的数据库。被关联的对象称作**值**。*相同的键， Map 只接受一个*。

- `Map.put(key, value)` 的作用是添加一个值（`value`，就是我们想要的），并将其与一个键（`key`，我们用它来查找）关联起来。 `Map.get(key)` 会得到与这个键（`key`）关联的值。

- `HashMap` 无序，使用了一种非常快速的算法，而该算法会控制顺序； `TreeMap` 会按照键的升序来排序； `LinkedHashMap` 则按照插入顺序来保存键，同时保留了 `HashMap` 的查找速度；

## 12.5. List

- `List` 承诺以特定的顺序维护元素。`List` 接口在 `Collection` 的基础上增加了一些方法，支持在 `List` 中间插入和移出元素。

- 有两种类型的 `List` :
  - 基本的 `ArrayList` ，擅长随机访问元素，但是在 `List` 的中间插入或删除元素比较慢；
  - `LinkedList` ， 提供了理想的顺序访问性能，在 `List` 的中间插入和删除元素的成本都比较低。 `LinkedList` 随机访问性能相对较差，但是与 `ArrayList` 相比提供了更多功能。

- List 常用API整理：

  | 方法名                                   | 说明                                                                               |
  | ---------------------------------------- | ---------------------------------------------------------------------------------- |
  | boolean add( E e )                       | 将指定的元素追加到此列表的末尾                                                     |
  | boolean add(int index, E e)              | 将指定的元素插入此列表中的指定位置                                                 |
  | boolean addAll(Collection c)             | 按指定集合的迭代器（可选操作）返回的顺序将指定集合中的所有元素附加到此列表的末尾。 |
  | boolean addAll(int index, Collection c)  | 将指定集合中的所有元素插入到此列表中的指定位置（可选操作）。                       |
  | boolean contains(Object o)               | 如果此列表包含指定的元素，则返回 true                                              |
  | boolean containsAll(Collectionc)         | 如果此列表包含指定 集合的所有元素，则返回true。                                    |
  | E get(int index)                         | 返回此列表中指定位置的元素。                                                       |
  | int indexOf(Object o)                    | 返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1。           |
  | boolean isEmpty()                        | 如果此列表不包含元素，则返回 true 。                                               |
  | E remove(int index)                      | 删除该列表中指定位置的元素（可选操作）。                                           |
  | boolean remove(Object o)                 | 从列表中删除指定元素的第一个出现（如果存在）（可选操作）。                         |
  | boolean removeAll(Collection c)          | 从此列表中删除包含在指定集合中的所有元素（可选操作）。                             |
  | void clear()                             | 从此列表中删除所有元素（可选操作）。                                              |
  | boolean retainAll(Collection c)          | 仅保留此列表中包含在指定集合中的元素（可选操作），实际上就是求“交集”。                       |
  | E set(int index, E element)              | 用指定的元素（可选操作）替换此列表中指定位置的元素。                               |
  | List subList(int fromIndex, int toIndex) | 返回此列表中指定的 fromIndex （含）和 toIndex之间的视图。                          |
  | Object[] toArray()                       | 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。         |
  | <T> T[] toArray(T[] a)                   | 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。 |

## 12.6. Iterator

- 不管是哪种集合，都必须有某种方法来插入元素，并将它们再次取出。毕竟这就是集合的主要工作 —— 持有事物；

- <u>**迭代器**（也是一种设计模式）</u>的概念实现了这种抽象。迭代器是一个对象，它可以再序列中移动，并用来选择该序列中的每个对象，而使用它的晨曦不用知道或者关系序列的底层结构。此外，迭代器通常是所谓的<u>**轻量级对象**</u>，创建成本很低。因为这个原因，我们经常会发现迭代器有一些看起来很奇怪的限制。例如，`Java` 的 `Iterator` 只能向一个方向移动。除了下面几点，我们对迭代器能做的事情不多。
  - 使用 `iterator()` 方法让 Collection 返回一个 `Iterator` 。这个迭代器将准备好返回序列中的第一个元素。
  - 使用 `next()` 方法获得序列中的下一个对象。
  - 使用 `hasNext()` 方法检查序列中是否还有更多对象。
  - 使用 `remove()` 方法删除该迭代器最近返回的元素。

``` java
public class SimpleIterator {
    public static void main(String[] args) {
        List<Pet> pets = new PetCreator().list(12);
        Iterator<Pet> it = pets.iterator();
        while (it.hasNext()){
            Pet p = it.next();
            System.out.print(p + " ");
        }
        System.out.println();
        // 如果情况允许的话，这种方式更简单
        for (Pet p : pets) {
            System.out.print(p + " ");
        }
        System.out.println();
        // 迭代器也可以用来删除元素
        it = pets.iterator();
        for (int i = 0; i < 6; i++) {
            it.next();
            it.remove();
        }
        System.out.println(pets);
    }
}
```

- <u>`迭代器`**统一了对集合的访问**</u>，分析下列案例：

``` java
public class CrossCollectionIteration {
    public static void display(Iterator<Pet> it){
        while (it.hasNext()){
            Pet p = it.next();
            System.out.print(p + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        List<Pet> pets = new PetCreator().list(8);
        LinkedList petsLL = new LinkedList(pets);
        HashSet<Pet> petsHS = new HashSet<>(pets);
        TreeSet<Pet> petsTS = new TreeSet<>(pets);
        display(pets.iterator());
        display(petsLL.iterator());
        display(petsHS.iterator());
        display(petsTS.iterator());
    }
}
```

- `display()` 没有包含与它所遍历的序列类类型相关的任何信息。显示出了 Iterator 的真正威力：<u>*能够将序列的遍历操作与序列的底层结构分离。*</u>

### 12.6.1. Iterable

- **`Iterable` 接口**，描述了“<u>*任何可以产生一个迭代器的东西*</u>”：

``` java
public class CrossCollectionIteration2 {
    public static void display(Iterable<Pet> ib){
        Iterator<Pet> it = ib.iterator();
        while (it.hasNext()){
            Pet p = it.next();
            System.out.print(p + " ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        List<Pet> pets = new PetCreator().list(8);
        LinkedList petsLL = new LinkedList(pets);
        HashSet<Pet> petsHS = new HashSet<>(pets);
        TreeSet<Pet> petsTS = new TreeSet<>(pets);
        display(pets);
        display(petsLL);
        display(petsHS);
        display(petsTS);
    }
}
```

- 这里所有的类都实现了 `Iterable` 接口，所以现在 `display()` 调用起来明显更简单了。

### 12.6.2. ListIterator

- `ListIterator` 是 `Iterator` 的一种更为强大的子类型，只有 List 类才会生成。尽管 `Iterator` 只能向前移动，但是 `ListIterator` 可以双向移动。它还可以生成相对于迭代器在列表中指向的当前位置的下一个和上一个元素的索引，并且可以使用 set() 方法替换它所访问过的最后一个元素。

- 通过 `listIterator()` ，我们可以生成一个指向 `List` 开始位置的 `ListIterator` 。还可以通过调用 `listIterator(n)` 来生成一个指向列表中索引为 `n` 的元素处的 `ListIterator` 。

``` java
public class ListIteration {
    public static void main(String[] args) {
        List<Pet> pets = new PetCreator().list(8);
        ListIterator<Pet> it = pets.listIterator();
        while (it.hasNext()){
            System.out.println(it.next() + ", " + it.nextIndex() + ", " + it.previousIndex() + ";");
        }
        System.out.println();
        // 反向
        while (it.hasPrevious()){
            System.out.print(it.previous() + " ");
        }
        System.out.println();
        System.out.println(pets);

        it = pets.listIterator(3);
        while (it.hasNext()){
            it.next();
            it.set(new Pet()); // 替换元素
        }
        System.out.println(pets);
    }
}
```

## 12.7. LinkedList

- 和 `ArrayList` 一样， `LinkedList` 实现了基本的 `List` 接口。但是与 `ArrayList` 相比， 它在 `List` 中间执行插入和删除操作的效率更高，不过随机访问的表现差一些。

- `LinkedList` 还添加了一些可以使其用作`栈`、`队列`或`双端队列（deque）`的方法。
  - `getFirst()` 和 `element()` 是完全相同的，返回列表的头部（第一个元素），而并不移除它，如果 `List` 为空，则抛出 `NoSuchElementException` 。 `peek()` 和这两个方法稍有不同，如果列表为空，则返回 `null` 。
  - `removeFirst()` 和 `remove()` 也是完全相同的，它们都会移除并返回列表的头，对于空列表则抛出 `NoSuchElementException` 。 `poll()` 稍有不同，如果列表为空，它会返回 `null` 。
  - `addFirst()` 在列表的开头插入一个元素；
  - `offer()` 和 `add()` 以及 `addLast()` 相同，都是向列表的尾部插入一个元素；
  - `removeLast()` 移除并返回列表中的最后一个元素。

## 12.8. Stack

- `栈（Stack）` 是一个 `“后进先出”（LIFO）`的集合。它有时被称作 **`下推栈`** ，因为不管我们最后“压入”的是什么，它都会第一个“弹出”。

- `Java 1.0` 就提供了 `Stack` 类，结果这个类的设计非常糟糕。*<u>注意：不要使用</u>*；
- `Java 6` 加入了 `ArrayDeque` ， 提供了直接实现栈功能的方法：

``` java
public class StackTest {
    public static void main(String[] args) {
        Deque<String> stack = new ArrayDeque<>();
        for (String s : "My dog has fleas".split(" ")) {
            stack.push(s);
        }
        while (!stack.isEmpty()){
            System.out.println(stack.pop());
        }

    }
}
```

- 尽管它在各方面的表现都像`栈`，但是我们任然必须把它声明为 `Deque` 。我们可以定义自己的 `Stack` ：

``` java
import java.util.ArrayDeque;
import java.util.Deque;

public class MyStack<T> {
    private Deque<T> storage = new ArrayDeque<>();
    public void push(T v) { storage.push(v); }
    public T peek() { return storage.peek(); }
    public T pop() { return storage.pop(); }
    public boolean isEmpty() { return storage.isEmpty(); }

    public static void main(String[] args) {
        MyStack<String> stack = new MyStack<>();
        for (String s : "My dog has fleas".split(" ")) {
            stack.push(s);
        }
        while (!stack.isEmpty()){
            System.out.println(stack.pop());
        }
    }
}
```

- 相关api 方法说明：
  - `push()` 接受一个 T 类型对象，压入栈；
  - `peek()` 返回栈顶元素，不会移除;
  - `pop()` 返回栈顶元素，并且移除;

## 12.9. Set

- `Set` 中不允许出现重复的对象值。对于等价对象的实例，如果尝试添加多个，那么 `Set` 会阻止；

- 查找通常是 `Set` 最重要的操作，所以我们通常会选择一个 `HashSet` 的实现，它针对快速查找做了优化；

- `Set` 与 `Collection` 有相同的接口，所以不像 `List` 的两种类型那样有额外的功能。相反， `Set` 就是一个 `Collection` ，只是行为不同。（*<u>这就是`继承`和`多态`的理想使用场景：**表现不同的行为**。</u>*）

- 三种 `Set` 实现的特点：
  - `HashSet` 输出的顺序没有明显的规律可循。`HashSet` 使用哈希来提升速度；
  - `TreeSet` 将元素排序存储在红黑树数据结构中，是有序的；
  - `LinkedHashSet` 也使用哈希来提升查找速度，但看起来是使用链表按照插入顺序来维护元素的。

## 12.10. Map

- `Map` 能够将对象映射到其他对象。

- 使用 `containsKey()` 和 `containsValue()` 来检查一个 `Map` ，查看其中是否包含某个键或某个值。

- 类似于数组和 `Collection` ， `Map` 也很容易扩展为多维；我们可以创建一个值为 `Map` 的 `Map` （那些 `Map` 的值可以是其他集合，甚至是其他 `Map` ）。因此，将集合组合起来快速生成强大的数据结构非常容易。例如，假设要记录拥有多个宠物的人，我们所需要的只是一个 `Map<Person, List<Pet>>` ；

- `Map` 可以返回一个包含其他所有键的 `Set` ，包含其所有值的 `Collection` ， 或者包含其键值对的 `Set` 。 `keySet()` 会生成一个 `Set` ， 包含 Map 中的所有键，我们在 `for-in` 语句中用来遍历整个 `Map` 。

## 总结

- 优化是个棘手的问题，最好的策略就是在不得不担心之前先不去管它（尽管理解这个问题总是好事）。

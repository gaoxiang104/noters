# 10. 接口

- [10. 接口](#10-接口)
  - [10.1. 抽象类和抽象方法](#101-抽象类和抽象方法)
  - [10.2. 接口定义](#102-接口定义)
    - [10.2.1. 默认方法](#1021-默认方法)
  - [10.2.2. 多重继承](#1022-多重继承)

## 10.1. 抽象类和抽象方法

- 在 `Instrument（乐器）` 示例中，创建此通用接口的唯一原因是，不同子类可以用不同的方式来表示这个接口。它建立了一种基本形式，这样就可以抽象出所有子类的共同之处。换言之，`Instrument（乐器）` 可称为 `抽象基类，或简称抽象类` ；

- Java 提供了一种称为 `抽象方法（abstract method）` 的机制。这是一个不完整的方法，它只有一个声明，没有方法体。以下是抽象方法声明的语法：

``` java
abstract void f();
```

- 包含抽象方法的类称为 `抽象类` 。*<u>如果一个类包含一个或多个抽象方法，则该类必须被定义为抽象类，否则编译器会产生编译错误。</u>*

- 如果试图创建一个抽象类的对象，会收到来自编译器的错误消息。这样就保证了抽象类的纯粹，不用担心它会被误用；

- 如果一个新类型继承了抽象类，并希望能生成自己的对象，那它必须为基类中的所有抽象方法提供方法定义。如果不这么做，那么子类也是抽象的，编译器将强制你使用 `abstract` 关键字来限定这个子类；

- 一个抽象类可以不包含任何抽象方法。如果一个类并不需要包含抽象方法，但同时还想阻止对它的任何实例化，这时将其定义为抽象类很有用了。

- 抽象类几乎对访问权限没有什么限制，但不允许使用 `private abstract` ，因此在 `AbstractAccess` 的任何子类中都不可能给这样的方法提供一个合法的定义。

- 抽象类和抽象方法很有用，因为它们明确了类的抽象性，并告诉用户和编译器自己的预期用途。抽象类还是有用的重构工具，它能让你轻松地在继承层次结构中向上移动通用方法。

## 10.2. 接口定义

- 使用关键字 `interface` 来定义接口。

``` java
// Java 8 之前的接口是这样的：
public interface PureInterface {
    int m1();
    void m2();
    double m3();
}
```

- 在 Java 8 之前，可以这样说：

> interface 关键字创建了一个完全抽象的类，它不代表任何实现。接口描述了一个类应该是什么样子和做什么的，而不是应该如何做。它确定了方法名、参数列表和返回类型，但不提供方法体。接口提供一种形式，并且除了某些受限制的情况外，它通常不提供实现。
> 
> 对于一个接口来说，它其实是在表示 “所有实现了这个特定接口的类看起来都这样”。因此，任何接口是用来在类之间建立 “协议” 的 。

- Java 8 允许 `默认方法` 和 `静态方法`;

- `接口` 和 `抽象类` 之间最显著的区别可能是两者的惯用方式。接口通常暗示“类的类型”或作为形容词来使用，例如 `Runnable` 和 `Serializable` ，而抽象类通常是类层次结构的一部分，并且是“事物的类型”，例如 `String` 或 `Instrument` 。

- 要创建接口，使用 `interface` 关键字而不是 <span style="text-decoration: line-through"> `class` </span> 关键字。与类一样，可以在 `interface` 关键字之前添加 `public` 关键字，如果去掉 `public` 关键字，将获得默认包访问权限；

- 接口也可以包含字段，但这些字段是隐式的 `static` 和 `final` 。

- 要创建一个符合特定接口（或一组接口）的类，使用 `implements` 关键字，它表示 “接口只是定义了它看起来是怎么样的，但现在要声明它是如何工作的”。

### 10.2.1. 默认方法

- Java 8 为 default 关键字找到了一个额外的用途（以前只在 switch 语句和注解中使用）。当在接口中使用时，default 会允许方法创建一个方法体，实现了该接口的类可以在不定义方法的情况下替换方法体。

``` java
// InterfaceWithDefault.java
public interface InterfaceWithDefault {
    void firstMethod();

    void secondMethod();

    default void newMethod() {
        System.out.println("newMethod");
    }
}

// Implementation2
public class Implementation2 implements InterfaceWithDefault {
    @Override
    public void firstMethod() {
        System.out.println("firstMethod");
    }
    @Override
    public void secondMethod() {
        System.out.println("secondMethod");
    }
    public static void main(String[] args) {
        InterfaceWithDefault i = new Implementation2();
        i.firstMethod();
        i.secondMethod();
        i.newMethod();
    }
}
```

- 添加默认方法的一个令人信服的原因是，它允许向现有接口中添加方法，而不会破坏已经在使用该接口的所有代码。默认方法有时也称为`防御方法（defender method）`或`虚拟扩展方法（virtual extension method）`;

- 在 JDK 9 中，接口里的 `default` 和 `static` 方法都可以是 `private` 的 。

## 10.2.2. 多重继承

- `多重继承`意味着一个类可以从多个基类型继承特性和功能。

- Java 严格来说是一种单继承语言：只能继承一个类（或抽象类）。可以实现任意数量的接口。

- 但在 Java 8 之后，通过默认方法，Java 拥有了多重继承的一些特性。将接口与默认方法结合，意味着可以结合来自多个基类的行为。因为接口任然不允许包含字段（接口里只有静态字段），所以字段任然只能来自单个基类或抽象类。也就是说，不能拥有有状态的多重继承；

``` java
interface One {
    default void first() {
        System.out.println("first");
    }
}

interface Two {
    default void second() {
        System.out.println("second");
    }
}

interface Three {
    default void third() {
        System.out.println("third");
    }
}

class MI implements One, Two, Three { // 实现多接口
}

public class MultipleInheritance { // 多重继承
    public static void main(String[] args) {
        MI mi = new MI();
        mi.first();
        mi.second();
        mi.third();
    }
}
```

- 当多个基类（接口）中存在相同行为（即方法。签名相同，方法名+参数列表）时，子类则必须重新该方法，否则编译器报错；重新写可以使用 `super` 关键字来选择一个基类实现，或者直接重新；
- 例如下面4个案例：

``` java
// 案例 1：
interface Bob1 {
    default void bob() { System.out.println("bob"); }
}
interface Bob2 {
    default void bob() { System.out.println("bob"); }
}
//class Bob implements Bob1, Bob2{}
// error : Bob inherits unrelated defaults for bob() from Bob1, Bob2

// 案例 2：
interface Sam1 {
    default void sam() { System.out.println("Sam1::sam"); }
}
interface Sam2 {
    default void sam(int i) { System.out.println(i * 2); }
}
class Sam implements Sam1, Sam2 {}

// 案例 3：
interface Max1 {
    default void max() { System.out.println("Max1::max"); }
}
interface Max2 {
    default int max() { return 47; }
}
//class Max implements Max1,Max2{}
// error: 'max()' in 'Max1' clashes with 'max()' in 'Max2'; attempting to use incompatible return type
// 试图使用不兼容的返回类型

// 案例 4：
interface Jim1{
    default void jim(){ System.out.println("Jim1::jim"); }
}
interface Jim2{
    default void jim(){ System.out.println("Jim2::jim"); }
}
class Jim implements Jim1,Jim2{
    @Override
    public void jim() {
        Jim2.super.jim(); // 使用super关键字来选择一个基类实现
    }
}

public class MICollision {
    public static void main(String[] args) {
        Jim jim = new Jim();
        jim.jim();
    }
}

```

# 6. 初始化和清理

- [6. 初始化和清理](#6-初始化和清理)
  - [6.1. 用构造器保证初始化](#61-用构造器保证初始化)
  - [6.2. 方法的重载](#62-方法的重载)
    - [6.2.1. 区分重载的方法](#621-区分重载的方法)
    - [6.2.2. 使用基本类型的重载](#622-使用基本类型的重载)
    - [6.2.3. 通过返回值区分重载方法](#623-通过返回值区分重载方法)

## 6.1. 用构造器保证初始化

- 在 Java 中，类的设计者可以通过编写`构造器`来确保每个对象的初始化；
- `构造器`的名字就是`类`的名字；
- 不带参数的构造器叫作`默认构造器（default constructor）`，也叫作`无参构造器（no-arg constructor）`，Java文档已经开始使用术语`零参数构造器（zero-argument constructor）`。
- 构造器也可以传入参数来指定如果创建对象。
- 如果类`Tree` 有一个构造器，它接受一个表示高度的整数参数，如：`Tree(int)`是唯一的构造器，编译器就不会让任何其他方式创建 `Tree` 对象；
- 构造器是一类特殊的方法，它`没有返回类型`;

## 6.2. 方法的重载

- 通常来说，同一个词可以表达几种不同的含义，这就是`重载（overload）`；
- Java 中，必须要有方法名重载的另一个因素是构造器。因为构造器的名字是由类名预先确定的，所以只能有一个构造器名字。
- 如果允许具有不同参数类型的方法有相同的名字，那就必须要有`方法重载`；
- 方法重载对于构造器是必需的，但也可以用于其他任何方法；

### 6.2.1. 区分重载的方法

- 每个重载方法必须有独一无二的参数类型列表。

### 6.2.2. 使用基本类型的重载

- 基本类型可以从较小类型自动提升到较大类型。
  - [参考代码](../../hsp/1_java_basics/code2/src/main/java/org/gx/onjava/chapter06_housekeeping/PrimitiveOverloading.java)
- 如果传入数据的类型比方法参数的类型更宽，就必须使用窄化转型。
  - [参考代码](../../hsp/1_java_basics/code2/src/main/java/org/gx/onjava/chapter06_housekeeping/Demotion.java)

### 6.2.3. 通过返回值区分重载方法

> “为什么只通过参数列表来区分重载方法？为什么不根据方法的返回值来区分？”

比如下面定义的两个方法虽然具有相同的名字和参数，但很容易就能通过返回值区分开来：

``` java
void f() {}
void f() {return 1;} 
```

只有编译器能从上下文中明确地判断出语句的含义，这种方式才是可行的。比如在 `int x = f()`中，x 的类型能够高手编译器，我们想要调用哪个版本的 `f()`，但还可以调用 `f()` 并忽略它的返回值。 这被称为 **调用方法的副作用** ，此时我们不关心返回值，而只是想要方法调用的其他效果。因此这样调用方法 `f();` 此时 Java 如何确定应该调用哪个 `f()`？阅读代码的人又该如何理解它呢？由于存在这些问题，我们不能使用返回值类型来区分重载方法。


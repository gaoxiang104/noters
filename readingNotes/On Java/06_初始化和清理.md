# 6. 初始化和清理

- [6. 初始化和清理](#6-初始化和清理)
  - [6.1. 用构造器保证初始化](#61-用构造器保证初始化)
  - [6.2. 方法的重载](#62-方法的重载)
    - [6.2.1. 区分重载的方法](#621-区分重载的方法)
    - [6.2.2. 使用基本类型的重载](#622-使用基本类型的重载)
    - [6.2.3. 通过返回值区分重载方法](#623-通过返回值区分重载方法)
  - [6.3. 无参构造器](#63-无参构造器)
  - [6.4. this关键字](#64-this关键字)
    - [6.4.1. 在构造器中调用构造器](#641-在构造器中调用构造器)
    - [6.4.2. static的含义](#642-static的含义)
  - [6.5. 清理：终结和垃圾收集](#65-清理终结和垃圾收集)
    - [6.5.1. finalize() 的作用](#651-finalize-的作用)
    - [6.5.2. 你必须执行清理](#652-你必须执行清理)
    - [6.5.3. 终止条件](#653-终止条件)
    - [6.5.4. 垃圾收集器的工作原理](#654-垃圾收集器的工作原理)
      - [6.5.4.1. 垃圾收集器：停止-复制算法](#6541-垃圾收集器停止-复制算法)
      - [6.5.4.2. 垃圾收集器：标记-清除算法](#6542-垃圾收集器标记-清除算法)
      - [6.5.4.3. 垃圾收集器：分代](#6543-垃圾收集器分代)
      - [6.5.4.4. 垃圾收集器：自适应](#6544-垃圾收集器自适应)
      - [6.5.5. 资源清理的总结:](#655-资源清理的总结)
  - [6.6. 成员初始化](#66-成员初始化)
  - [6.7. 构造器初始化](#67-构造器初始化)
    - [6.7.1. 初始化顺序](#671-初始化顺序)
    - [6.7.2. 静态数据的初始化](#672-静态数据的初始化)
    - [6.7.3. 显示的静态初始化](#673-显示的静态初始化)
    - [6.7.4. 非静态实例初始化](#674-非静态实例初始化)
  - [6.8. 数组初始化](#68-数组初始化)
    - [6.8.1. 动态数组创建](#681-动态数组创建)
    - [6.8.2. 可变参数列表](#682-可变参数列表)
  - [6.9. 枚举类型](#69-枚举类型)
  - [6.10. 新特性：局部变量类型推断](#610-新特性局部变量类型推断)

## 6.1. 用构造器保证初始化

- 在 Java 中，类的设计者可以通过编写`构造器`来确保每个对象的初始化；
- `构造器`的名字就是`类`的名字；
- 不带参数的构造器叫作`默认构造器（default constructor）`，也叫作`无参构造器（no-arg constructor）`，Java文档已经开始使用术语`零参数构造器（zero-argument constructor）`。
- 构造器也可以传入参数来指定如果创建对象。
- 如果类`Tree` 有一个构造器，它接受一个表示高度的整数参数，如：`Tree(int)`是唯一的构造器，编译器就不会让任何其他方式创建 `Tree` 对象；
- 构造器是一类特殊的方法，它`没有返回类型`;

## 6.2. 方法的重载

- 通常来说，同一个词可以表达几种不同的含义，这就是`重载（overload）`；
- Java 中，必须要有方法名重载的另一个因素是构造器。因为构造器的名字是由类名预先确定的，所以只能有一个构造器名字。
- 如果允许具有不同参数类型的方法有相同的名字，那就必须要有`方法重载`；
- 方法重载对于构造器是必需的，但也可以用于其他任何方法；

### 6.2.1. 区分重载的方法

- 每个重载方法必须有独一无二的参数类型列表。

### 6.2.2. 使用基本类型的重载

- 基本类型可以从较小类型自动提升到较大类型。
  - [参考代码](../../hsp/1_java_basics/code2/src/main/java/org/gx/onjava/chapter06_housekeeping/PrimitiveOverloading.java)
- 如果传入数据的类型比方法参数的类型更宽，就必须使用窄化转型。
  - [参考代码](../../hsp/1_java_basics/code2/src/main/java/org/gx/onjava/chapter06_housekeeping/Demotion.java)

### 6.2.3. 通过返回值区分重载方法

> “为什么只通过参数列表来区分重载方法？为什么不根据方法的返回值来区分？”

比如下面定义的两个方法虽然具有相同的名字和参数，但很容易就能通过返回值区分开来：

``` java
void f() {}
void f() {return 1;} 
```

只有编译器能从上下文中明确地判断出语句的含义，这种方式才是可行的。比如在 `int x = f()`中，x 的类型能够高手编译器，我们想要调用哪个版本的 `f()`，但还可以调用 `f()` 并忽略它的返回值。 这被称为 **调用方法的副作用** ，此时我们不关心返回值，而只是想要方法调用的其他效果。因此这样调用方法 `f();` 此时 Java 如何确定应该调用哪个 `f()`？阅读代码的人又该如何理解它呢？由于存在这些问题，我们不能使用返回值类型来区分重载方法。

## 6.3. 无参构造器

- 无参构造器（又叫“默认构造器”或“零参数构造器”）是没有参数的构造器，用于创建“默认对象”。
- 如果创建了一个`没有构造器`的类，编译器会自动为这个类添加一个无参构造器。

## 6.4. this关键字

- this关键字：想在一个方法里获得对当前对象的引用；
- this关键字只能在非静态方法中使用。
- 当你想在方法里调用对象时，直接使用this就可以，因为它表示对该对象的引用。可以像使用任何其他对象引用一样使用this；
- 如果从类的一个方法中调用该类的另一个方法，那么就没必要使用this，直接调用即可。编译器会自动帮你添加。
- 应用场景：
  - 经常用在return语句中，来返回当前对象的引用；
  - this关键字还可以将当前对象传递给另一个方法；

### 6.4.1. 在构造器中调用构造器

- 当一个类里有多个构造器时，有时会希望从一个构造器里调用另一个构造器，以避免重复的代码。可以使用this关键字进行此类调用。

- 通常情况下，当提及this时，指的是“这个对象”或“当前对象”，并且this本身表示对当前对象的引用。在构造器中，如果在this后加了参数列表，那么就有了不同的含义，它会显示调用与该参数列表匹配的构造器。

- [参考代码: ~/housekeeping/Flower.java](../../hsp/1_java_basics/code2/src/main/java/org/gx/onjava/chapter06_housekeeping/Flower.java)

- this的另一种用法。参数和成员数据名字相同时，可以使用 `this.s`来表示成员数据；

### 6.4.2. static的含义

- 了解了this关键字后，就可以更全面地理解将一个方法设为static意味着什么：这种方法没有this。
- 不能从静态（static）方法内部调用非静态方法（反过来倒是可以的）；
- 可以在没有创建对象的时候，直接通过类本身调用一个静态方法。事实上这正是静态方法的主要用途。
- 一个类里的静态方法可以访问其他静态方法和静态字段；

## 6.5. 清理：终结和垃圾收集

### 6.5.1. finalize() 的作用

- finalize() 的使用仅限于一种特殊的情况：对象以某种特殊方式分配存储空间，而不是通过创建对象来分配；
- 假设你的对象在`不使用 new `的情况下分配了一块“特殊”内存。垃圾收集器只知道如果释放由 new 分配的内存，所以它不知道如何释放对象的这块“特殊”内存。
- `未使用 Java 的new分配内存`：
  - 采用了类似 C 语音的机制，在Java中，就是使用`本地方法`来实现（通过 native），例如通过调用 C 的 malloc() 系列函数来分配存储空间。此时，应该在 finalize() 方法中调用 C 的 free() 函数。

### 6.5.2. 你必须执行清理

- Java 语音规范不仅不保证finalize()方法会被及时执行，而且根本就不保证它们会被执行。

- 本书建议“永远不要直接调用 finalize() 方法”！
  - 为什么？ -- 假设用 finalize() 方法关闭已经打开的文件，由于 finalize() 方法有可能永远不执行，也可能被延迟执行，就可能导致该文件迟迟未能关闭，甚至永远没有关闭，最终导致大量的文件会保留在打开状态。积累到一定程度，程序就可能再也无法打开文件，导致运行失败！

### 6.5.3. 终止条件

- finalize()还有一个有趣的用法，它不依赖于每次都被调用。这就是对象`终止条件`的验证；
  - 例如：在 finalize() 方法中验证打开的文件是否在对象销毁之前就被关闭了，如果在执行 finalize() 时，文件的状态还是打开状态，可以抛出异常。

### 6.5.4. 垃圾收集器的工作原理

- 垃圾收集：
  - Java 虚拟机（JVM）垃圾收集器（Garbage Collector）提供的一种用于在`空闲时间` `不定时回收` `任何对象引用的对象占据的内存空间`的一种机制。

- 垃圾收集器的特征
  - 停止-复制（stop-and-copy）
  - 标记-清除（mark-and-sweep）
  - 分代（generation）
  - 自适应（adaption）

#### 6.5.4.1. 垃圾收集器：停止-复制算法

- 程序首先停止，然后将所有存活对象从一个堆复制到另一个堆，剩下的就都是垃圾。当一个对象从一个地方移动到另一个地方时，所有指向该对象的引用都必须修改。

- 该算法问题：
  - 你需要两个堆，然后在这两个独立的堆之间来回复制内存，这比实际需要多了一倍内存；
  - 一旦程序变得稳定，它可能很少产生垃圾，甚至没有。尽管如此，复制收集器仍会将所有内存从一个地方复制到另一个地方；

#### 6.5.4.2. 垃圾收集器：标记-清除算法

- 该算法从栈和静态存储开始，遍历所有引用以查找存活对象。每当它找到一个存活对象，就会给该对象设置一个标志。此时尚未开始收集，只有在标记过程完成后才会进行清除。在清除过程中，没有标记的对象被释放，但不会发生复制。

- 该算法的特征：
  - 对于一般用途，“标记 - 清除”算法相当慢；在垃圾很少或没有的时候，它的速度就很快了。

#### 6.5.4.3. 垃圾收集器：分代

![6-1](./imgs/6-1.png)

- 创建一个对象的时候，总是在`Eden区`操作，当这个区满了，那么就会触发一次`Young GC`，也就是年轻代的垃圾回收；
- 当`Eden区`再次被用完，就再触发一次`Young GC`，此时会将`Eden区`和`From区`还在被使用的对象复制到`To区`；
- 在下一次`Young GC`到时候，则是将`Eden区`和`To区`还在被使用的对象复制到`From区`；
- 若干次`Young GC`后，有些对象在`From区`和`To区`之间来回游荡，一旦超出阀值，就将他们复制到`老年代`。如果`老年代`被用完，则执行`Full GC`；

#### 6.5.4.4. 垃圾收集器：自适应

- JVM会监控垃圾收集器的效率，如果所有对象都很稳定，垃圾收集器效率很低的话，它会切换到“标记-清除”算法。同样，JVM会跟踪标记和清除的效果，如果堆里开始出现很低碎片，它会切换回“停止-复制”算法。

#### 6.5.5. 资源清理的总结:

- 在Java中始终使用new创建对象，此时，垃圾收集器会自动释放存储空间；
- 如果在 Java 中通过其他机制创建了本地对象，则使用 finalize() 管理内存的释放，并通过垃圾收集器自动调用；
- 如果需要终止对象封装的资源（如：文件或线程），请提供一个显示的终止方法，如显示定义 close() 方法；

## 6.6. 成员初始化

- 局部变量在使用之前必须要被正确的初始化，否则编译时不通过；

- 成员变量的默认初始化：
  | 类型    | 默认初始化值 |
  | ------- | ------------ |
  | boolean | false        |
  | char    | [NUL]        |
  | byte    | 0            |
  | short   | 0            |
  | int     | 0            |
  | long    | 0            |
  | float   | 0.0          |
  | double  | 0.0          |
  | Object  | null         |

- 指定初始化
  - 一种直接的方法就是在类中定义变量时分配；还可以调用方法来提供初始值；

  ``` java
  public class InitialValues2{
    boolean bool = true;
    int i = 999;
    double d = f();
    double f(){
      return 3.14159;
    }
  }
  ```

  - 非法的向前引用，编译器对向前引用（forward referencing）会发出警告，这里的问题和初始化顺序有关，而不是程序的编译方式。

  ``` java
  public class InitialValues3{
    // int j = g(i); //非法的向前引用， i还没有被初始化
    int i = f();
    int f() {return 11;}
    int g(int n) {return n *10;}
  }
  ```

## 6.7. 构造器初始化

- 可以用构造器来执行初始化，这为编程带来了更大的灵活性，可以在运行时调用方法来设置初始值。
- **在构造器执行之前，会自动初始化。**

### 6.7.1. 初始化顺序

- 类中的变量定义顺序决定了初始化的顺序。
- 即使分散到方法定义之间，变量定义仍然会在任何方法（包括构造器）调用之前就被初始化。

### 6.7.2. 静态数据的初始化

- 无论创建了多少对象，静态数据都只有一份存储空间。
- > static关键字不能用于`局部变量`，而仅适用于字段（成员变量）。
- 如果一个字段时static的基本类型，并且没有初始化，那它就会获得基本类型的标准初始值。如果它是一个对象引用，则默认初始值为null。

- 总结对象创建的过程，假设有一个名为 `Dog` 的类
  1. 尽管没有显示使用`static`关键字，<u>但构造器实际上也是静态方法</u>。因此，第一次创建类型为`Dog`的对象时，或者第一次访问Dog的静态方法或静态字段时，Java解释器会搜索类路径来定位`Dog.class`文件。
  2. 当 `Dog.class` 被加载后（这将创建一个Class对象），它的所有静态初始化工作都会执行。因此，静态初始化只在Class对象首次加载时发生一次。
  3. 当使用`new Dog()`创建对象时，构建过程首先会在堆上为Dog对象分配足够的存储空间。
  4. 这块存储空间会被清空，然后自动将该Dog对象中的所有基本类型设置为其默认值，而引用会被设置为null。
  5. 执行所有出现在字段定义处的初始化操作。
  6. 执行构造器。正如将在第8章中看到的，这实际上可能涉及相当多的动作，尤其是这涉及<u>继承</u>时。

### 6.7.3. 显示的静态初始化

- Java允许在一个类里将多个静态初始化语句放在一个特殊的“静态子句”里（有时称为`静态块`）.例如：

  ``` java
  public class Spoon{ // 勺子
    static int i;
    static {
      i=47;
    }
  }
  ```

- 尽管看起来有点像一个方法，但它只是在static关键字后加了一段代码。这段代码和其他静态初始化语句一样，只执行一次：第一次创建该类的对象时，或第一次访问该类的静态成员时（即使从未创建过该类的对象）。

### 6.7.4. 非静态实例初始化

- Java提供了一种称为实例初始化（instance initialization）的类似语法，用于初始化每个对象的非静态变量。

  ``` java
  public class Chopstick{ // 筷子
    int i;
    {
      i=47;
    }
  }
  ```

- 除了缺少static关键字外，实例初始化子句看起来与静态初始化子句完全相同。
- 此语法对于支持匿名内部类的初始化是必需的，但也可以用来保证无论调用哪个显示的构造器，某些操作都会发生。
- 实例初始化子句在构造器之前执行。

## 6.8. 数组初始化

- 数组是一个对象序列或基本类型序列，其中含有的元素类型相同，用一个标识符名字打包在一起。
- 数组通过方括号`索引操作符（indexing operator）[]`来定义和使用。
- 要定义一个数组引用，在类型名字后面加上方括号即可：`int[] a;`。
- 编译器不允许指定数组的大小。现在所拥有的只是对数组的引用，并没有为数组对象本身分配任何空间。
- 要为数组分配空间，就必须编写一个初始化表达式。
- 对于数组，初始化可以出现在代码中的任何位置，*<u>但也可以使用一种特殊的初始化表达式，它只能在创建数组的地方出现。这个特殊的初始化是一组用花括号括起来的值</u>* ：`int[] a = {1,2,3}` ;

- 所有数组都有一个固有成员 `length`（无论是对象数组或基本类型数组），可以通过它来查询数组中有多少个元素，但不能对其进行修改。
- Java中的数组从`元素0`开始计数，因此可以索引的最大下标数是`length - 1`。
- 如果`越界`，Java则会通过抛出运行时错误（即异常）来保护免受此类问题的影响。

### 6.8.1. 动态数组创建

- 如果在编写程序时不知道数组中的需要多少个元素，那该怎么办？只需使用new来创建数组中的元素即可。
- 即使是基本类型数组，也可以使用new来创建（new 不能创建一个非数组的基本类型）： `int[] a = new int[5]`;
- 数组里的基本类型元素会自动初始化为空值（数值和char是0，boolean是false）；
- 可以使用花括号包围列表来初始化对象数组。有两种形式：

  ``` java
    Integer[] a = {1,2,3,}; // 形式一
    Integer[] b = new Integer[]{1,2,3,}; // 形式二
  ```

  - 在这两种形式下，初始值列表的最后一个逗号都是可选的（此功能可以让维护长列表更容易）；
  - 虽然第一种形式（定义了a）很有用，但局限性更大，它只能用在定义数组的时候。
  - 可以在任何地方使用第二种形式（定义了b），甚至在方法调用中也可以；例如：`Other.main(new Integer[]{1,2,3});`；

### 6.8.2. 可变参数列表

- Java提供了类似于C语言`可变参数列表（variable argument list）`，用来创建和调用可变参数的方法。
- 使用省略号来定义一个可变参数列表，例如：

  ``` java
    static void printArray(Object... args) {
      // 方法体
    }
  ```

  - 可以将0个参数传递给可变参数列表。例如调用上面的方法：`printArray()`；

- **注意：** 可变参数列表使用重载过程变得更复杂，例如：
  
  ``` java
    static void f(String... args) {
      // 方法体
    }
    static void f(Integer... args) {
      // 方法体
    }
    static void main(String[] args){
      f("a","b","c");
      f(1,2,3);
      // f(); // 无法编译 —— 有歧义
    }
  ```

  - 当不带参数调用f()时，编译器就不知道该调用哪一个了。

## 6.9. 枚举类型

- Java 5 中添加了`enum`关键字，它看似一个很小的特性，但当把元素组合起来并使用一组`枚举类型`来表示时，它会让编程变得更加轻松。

``` java
public enum Spiciness { // 辣
    NOT, MILD, MEDIUM, HOT, FLAMING
}
```

- 使用enum，只需要创建一个该类型的引用，并将其分配给某个实例：

``` java
public class SimpleEnumUse {
    public static void main(String[] args) {
        Spiciness howHot = Spiciness.MEDIUM;
        System.out.println(howHot);
    }
}
/* OUTPUT:
MEDIUM
 */
```

- 创建enum时，编译器会自动添加一些有用的功能：
  - 编译器添加了`toString()`方法，方便显示enum实例的名字；
  - 编译器添加了`ordinal()`方法，来表示特定enum常量的声明顺序
  - 编译器添加了`values()`方法；

- enum有一个很好的特性，就是可以在switch语句中使用；

## 6.10. 新特性：局部变量类型推断

- JDK 11 提供了一个用来简化局部变量定义的特性。它最先在 JDK 10 中添加，但随后在 JDK 11 中进行了改进。`在一个局部定义中（即在方法内部）`，编译器可以自动发现类型。这就是`类型推断（type inference）`，我们可以通过 `var`关键字启用它；

``` java
class Plumbus {
}

public class TypeInference {
    void method() {
        // 显示类型：
        String hello1 = "Hello";
        // 类型推断：
        var hello = "Hello";
        // 用户定义的类型也起作用：
        Plumbus pb1 = new Plumbus();
        var pb2 = new Plumbus();
    }

    static void staticMethod() {
        var hello = "Hello";
        var pb2 = new Plumbus();
    }
}

class NoInference { // 不能使用推断类型的场景
    String field1 = "Field initialization";
    // var field2 = "Can't do this"; 

    void method() {
        // var noInitializer; // No inference data
        // var aNull = null; // No inference data
    }
    
//    var inferReturnType(){
//        return "Can't infer return type";
//    }
}
```

- 使用var时的一些限制：
  - 不能在字段（类的属性）上使用类型推断，即使看起来我们已经有了足够的信心来推断。
  - 如果不提供任何初始化数据，或者提供了`null`，编译器就没有可以推断类型的信息。
  - 不能在方法返回时使用，编译器似乎没有足够的信息来确定方法的返回类型。
  - 类型推断不能用于方法的参数。

- <u>类型推断十分适合for循环；</u>

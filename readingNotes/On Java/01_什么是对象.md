# 1. 什么是对象

- [1. 什么是对象](#1-什么是对象)
  - [1.1. 抽象的历程](#11-抽象的历程)
  - [1.2. 对象具有接口](#12-对象具有接口)
  - [1.3. 对象可以提供服务](#13-对象可以提供服务)
  - [1.4. 隐藏的实现](#14-隐藏的实现)
  - [1.5. 复用实现](#15-复用实现)
  - [1.6. 继承](#16-继承)
    - [1.6.1. is-a关系与is-like-a关系](#161-is-a关系与is-like-a关系)
  - [1.7. 多态](#17-多态)
  - [1.8. 单根层次结构](#18-单根层次结构)
  - [1.9. 集合](#19-集合)
    - [1.9.1. 参数化类型（泛型）](#191-参数化类型泛型)
  - [1.10. 对象的创建和生命周期](#110-对象的创建和生命周期)
  - [1.11. 异常处理](#111-异常处理)

**'面向对象编程'**（Object-Oriented Programming, OOP）;

## 1.1. 抽象的历程

- 代表了纯粹的面向对象编程方式的 5 个基本特征：
  1. **万物皆对象**。你可以把对象想象为一种神奇的变量，它可以存储数据，同时你可以“发出请求”，让它执行一些操作。对于你想要解决的问题中的任何元素，你都可以在程序中用对象来呈现（比如狗、建筑、服务等）。
  2. **一段程序实际上就是多个对象通过发送消息来通知彼此要干什么**。当你向一个对象“发送消息”时，实际情况是你发送了一个请求去调用该对象的某个方法。
  3. **从内存角度而言，每一个对象都是由其他更为基础的对象组成的**。换句话说，通过将现有的几个对象打包在一起，你就创建了一种新的对象。这种做法展现了对象的简单性，同时隐藏了程序的复杂性。
  4. **每一个对象都有类型**。具体而言，每一个对象都是通过某个类生成的实例，这里说的“类”就（几乎）等同于“类型”。一个类最为显著的特性是“你可以发送什么消息给它”。
  5. **同一类型的对象可以接收相同的消息**。稍后你就会意识到这句话的丰富含义。举例来说,因为一个“圆形”对象同样也是一个“形状”对象,所以“圆形”也可以接收“形状”类型的消息。这就意味着,你为“形状”对象编写的代码自然可以适用于任何的“形状”子类对象。这种可替换性是面向对象编程的一个基石。

> Grady Booch 对对象做了一种更为简洁的描述：
>
> ***对象具有状态、行为及标识***。这意味着对象可以拥有属于自己的内部数据（赋予其状态）、方法（用于产生行为），同时每一个对象都有别于其他对象。也就是说，每一个对象在内存中都有唯一的地址。

## 1.2. 对象具有接口

“鱼的类别和鸟的类别”。所有的对象，哪怕是相当独特的对象，都能被归为某一类，并且同一类对象拥有一类共同的行为和特征。

创建抽象数据类型（即“类”）是面向对象编程的一个基本概念。抽象数据类型的工作原理和内置类型几乎一样：你可以创建某种类型的变量（在面向对象领域，这些变量叫作“对象”或“实例”)，随后你就可以操作这些变量（叫作“发送消息”或“发送请求”，即你发送指令给对象，然后对象自行决定怎么处理)。同一类型的所有成员（或元素)都具有一些共性，比如：每一个账户都有余额，每一位出纳员都能处理存款业务。同时，每一个成员都具有自己的专属状态，比如：每一个账户的余额都是不同的，每一位出纳员都有名字。因此，对于所有这些成员，包括每一位出纳员、每一位顾客、每一个账户，以及每一笔交易等，我们都能够在程序中用一个唯一的实体来表示。这种实体就是对象，同时每一个对象所归属的类决定了对象具有何种行为特征。

> ***统一建模语言（Unified Modeling Language, UML）***。

## 1.3. 对象可以提供服务

当你开发一个面向对象程序或理解其设计时，一个上佳的方法是将对象想象成“服务提供者”。

每一个对象都提供了一种配套服务。***在面向对象领域，出色的设计往往意味着一个对象只做好一件事，`绝不贪多`***。

## 1.4. 隐藏的实现

类的创建者负责在创建新的类时，只暴露必要的接口给客户端程序员，同时隐藏其他所有不必要的信息。

设置`访问控制`的原因就是防止客户程序员接触到他们本不该触碰的内容，即那些用于数据类型内部运转的代码，而非那些用于解决特定问题的接口部分。

Java提供了3个显式关键字来设置访问控制，即`public`、`static` 和 `protected` 。这些关键字叫作“访问修饰符”（access specifier）

Java还提供一种“默认”访问权限，通常叫作“包访问”（package access），意思是一个类可以访问同一个包里的其他类，但是private内容一样不可以访问。

## 1.5. 复用实现

复用一个类最简单的方法是直接使用这个类所生成的对象，不过你也可以把这个对象放到另一个新类里面。新创建的类可以自由任意数量和类型的对象组成，也可以任意组合这些对象，以满足想要的功能。

因为利用已有的类组合成一个新的类，所以这个概念叫作“组合”（composition）。如果组合是动态的，通常叫作“聚合”（aggregation）。

组合通常代表`一种“有”（has-a）的关系`，比如“汽车有发动机”。

在创建新类时应首先考虑组合，因为使用组合更为简单灵活，设计也更为清晰简洁。

## 1.6. 继承

当我们大费周折才创建了一个类之后，如果不得不再创建一个与之功能极为相近的类，这种滋味一定不太好受。如果我们能复用现有的类，并且在该复制类的基础上再做一些增补的话，那就太妙了。实际上，这就是继承给我们带来的好处。

除了一点：如果最初的类（叫作 “基类” “超类” 或“父类”）发生了变化，那么被修改的“复制”类（叫作 “派生类” “继承类” 或“子类”）同样会发生变化。

### 1.6.1. is-a关系与is-like-a关系

如果子类和基类的类型时完全相同的，因为它们的接口一摸一样。结果就是，你可以直接用子类的对象代替基类的对象。这种纯替换关系通常叫作“替换原则”。从某种意义上说，这是一种理想的继承方式。`这种情况下基类和子类直接的关系通常叫作“is-a”关系，意思是“A是B”，比如“圆形是一个形状”。`

有时候，你会为子类的接口添加新的内容，从而扩展了原有的接口。在这种情况下，子类的对象依然可以代替基类的对象，但是这种代替方案并不完美，因为不能通过基类的接口获取子类的新方法。`我将这种关系描述为“is-like-a”关系，意思是“A像B”,即子类在拥有基类接口的同时，也拥有一些新的接口，所以不能说两者是完全等同的。`

## 1.7. 多态

在编程中涉及类型层次时，完美通常会将一个对象视为其基类的一个实例，而不是对象实际的类。这种方式可以让你在编写代码时不依赖具体的类。

面向对象语言使用的“后期绑定”机制，当你向某个对象发送消失时，直到运行时才会确定哪一段代码会被调用。

将子类视为基类的过程叫作“向上转型”（upcasting）。

## 1.8. 单根层次结构

所谓`单根层次结构`是所有的类都应该默认继承某一个基类，Java中这个终极基类的名字是 `Object`。

- 单根层次优点：
  - 所有对象都具有共同的接口，因此它们都属于同一个终极基类。
  - 有利于实现垃圾收集器（garbage collector）。

## 1.9. 集合

创建一种新类型的对象，这种对象通过保存其他对象的引用来解决：“你不知道解决一个特定的问题需要用到多少个对象，也不知道这些对象会存放多久，你甚至不知道该如何保存这些对象。”

这种新对象通常叫作`集合`（也可以叫作“容器”），它会根据你放入其中的内容自行调整空间。

在Java的库中，不同的集合具有不同的用途。比如，有几个不同的`List`类（用于保存序列），几个`Map`类（也叫“关联数组”，用于关联对象），几个`Set`类（用于保存不同类型的对象），以及一些队列（`queue`）、树（`tree`）、栈（`stack`）等。

### 1.9.1. 参数化类型（泛型）

将基类转换成子类的过程叫作“向下转型”（downcasting）。

Java 5 新增的主要特性之一是支持参数化类型（parameterized type），也叫做“泛型”（generics）。可以通过在一对尖括号中间加上类名来定义泛型。

## 1.10. 对象的创建和生命周期

内存池里动态创建对象，这个内存池叫作“堆”（heap）。如果使用这个方案，直到运行时你才能知道需要多少对象，以及它们的生命周期和确切的类型什么。

Java 只允许动态分配内存。

Java的底层支持`垃圾收集器`（garbage collector）机制，它会自动找到无用的对象并将其销毁。

## 1.11. 异常处理

异常处理则是将编程语言甚至是操作系统和错误处理机制直接捆绑在一起。异常是从错误发生之处“抛出”的对象，而根据错误类型，它可以被对应的异常处理程序所“捕获”。

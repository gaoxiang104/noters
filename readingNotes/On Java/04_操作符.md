# 4. 操作符

- [4. 操作符](#4-操作符)
  - [4.1. 使用Java操作符](#41-使用java操作符)
  - [4.2. 优先级](#42-优先级)
  - [4.3. 赋值](#43-赋值)
  - [4.4. 算术操作符](#44-算术操作符)
    - [4.4.1. 一元加操作符和一元减操作符](#441-一元加操作符和一元减操作符)
  - [4.5. 自动递增和自动递减](#45-自动递增和自动递减)
  - [4.6. 关系操作符](#46-关系操作符)
  - [4.7. 逻辑操作符](#47-逻辑操作符)
    - [4.7.1. 短路](#471-短路)
  - [4.8. 字面量](#48-字面量)
    - [4.8.1. 字面量里的下划线](#481-字面量里的下划线)
    - [4.8.2. 科学记数法（又称“指数记数法”）](#482-科学记数法又称指数记数法)
  - [4.9. 按位操作符](#49-按位操作符)
  - [4.10. 位移操作符](#410-位移操作符)
  - [4.11. 三元操作符](#411-三元操作符)
  - [4.12. 字符串操作符 + 和 +=](#412-字符串操作符--和-)
  - [4.13. 使用操作符时常犯的错误](#413-使用操作符时常犯的错误)
  - [4.14. 类型转换操作符](#414-类型转换操作符)
    - [4.14.1. 截尾和舍入](#4141-截尾和舍入)
    - [4.14.2. 提升](#4142-提升)
  - [4.15  Java没有 sizeOf()](#415--java没有-sizeof)

## 4.1. 使用Java操作符

- 操作符接收一个或多个参数，然后生成一个新的值。
- 所有操作符都是通过它们的操作数来生成新值的。
- 另外，有些`操作符会修改操作数自身的值`，这也叫作“副作用”。
- 几乎所有的操作符都只能操作基本类型。例外的是`=`、`==`和`!=`，它们也能操作对象。另外，`String`类也支持`+`和`+=`；

## 4.2. 优先级

- 当多个操作符同时存在时，操作符的优先级决定了表达式的计算顺序。
- Java对计算顺序做了特别规定。最简单的规则就是先`乘除后加减`。
- 程序员经常会忘记其他优先级规则，可以用`括号来明确指定计算顺序`。

## 4.3. 赋值

- 操作符`=`号用来赋值。它的意思是“取等号右边的值（称‘右值’），把它复制给等号左边（称‘左值’）”。
- 右值可以是任何常量、变量或者可以生产值的表达式。左值必须是一个独特的命名变量（也就是说，必须有一个物理空间来存储右值）。
- 基本类型的赋值是很直观的。基本类型存储了实际的值，而非指向一个对象的引用，所以在赋值时，直接将一个地方的内容**复制**到另一个地方。
- 对象赋值时，我们`真正操作的是这个对象的引用`。所以当“将一个对象赋值给另一个对象”时，其实是将这个引用从一个地方赋值到另一个地方。这种现象通常称作`别名`，是Java操作对象的一种基本方式。
- 方法调用中的别名：将一个对象作为参数传递给方法时，也会产生别名。

## 4.4. 算术操作符

- Java的基本算术操作符与其他大多数编程语言相同，包括：加法（+）、减法（-）、乘法（*）、除法（/）和取模（%，它从除法中产生余数）。

- 快捷运算符，可以同时进行运算和赋值操作。比如，把 x 加4，然后将结果赋回给x，可以这么写：`x += 4`；

> 为了生成随机数，上面的程序首先创建了一个 `Random` 对象。如果创建时没有传递任何参数，Java会使用当前时间作为随机生成器的种子，这样就能在程序每次执行时产生不同的输出。通过在创建Random对象时提供种子（用作在每次执行程序时都生成相同的随机数）。

### 4.4.1. 一元加操作符和一元减操作符

- 一元减（-）和一元加（+）与二元加减使用的是相同的符号。编译器会根据表达式的书写形式自动判断出使用的是哪一种。例如：`x = a * -b`; 但是阅读者可能会被搞糊涂，所以应该更明确地写成： `x = a * (-b)`；

## 4.5. 自动递增和自动递减

- Java也提供了大量的快捷运算符，这些快捷运算符方便了代码输入，如果用得好会使代码更容易阅读，但有时也可能使代码更难理解。

- 递减操作符是`--`，意为“减少一个单位”；递增操作符是`++`，意为“增加一个单位”；

- 递增和递减操作符有两种使用方式，通常称为`前缀式`和`后缀式`.
  - `前缀递增`表示++操作符位于变量之前；例如：`++i`；程序会先执行运算，然后返回生成的结果；
  - `后缀递增`表示++操作符位于变量之后；例如：`i++`；程序则会先返回变量的值，然后再执行运算；

``` java
public class AutoInc {
  public static void main(String args[]) {
    int i = 1;
    System.out.println("i: " + i); // i: 1
    System.out.println("++i: " + ++i); // 前缀递增 ++i: 2
    System.out.println("i++: " + i++); // 后缀递增 i++: 2
    System.out.println("i: " + i); // i: 3
    System.out.println("--i: " + --i); // 前缀递减 --i: 2
    System.out.println("i--: " + i--); // 后缀递减 i--: 2
    System.out.println("i: " + i); // i: 1
  }
}
```

> 注意： 对于前缀形式，我们在执行完运算后才得到返回值。但对于后缀形式，则是先获得返回值再执行运算；

## 4.6. 关系操作符

- 关系操作符会根据操作数的值之间的关系生成一个布尔结果。
- 如果关系为真，关系表达式生成true；如果关系不为真，则生成false。
- 关系操作符包括小于（<）、大于（>）、小于等于（<=）、大于等于（>=）、等于（==）以及不等于（!=）。

- 测试对象是否相等，如下代码：

  ``` java
  public class Equivalence { // 对等，等效
      static void show(String desc, Integer n1, Integer n2) {
          System.out.println(desc + ":");
          System.out.printf("%d==%d %b %b%n", n1, n2, n1 == n2, n1.equals(n2));
      }

      public static void test(int value) {
          Integer i1 = value; // 1 自动转换为Integer
          Integer i2 = value;
          show("Automatic", i1, i2);
          Integer r1 = new Integer(value); // 2 使用new的方式
          Integer r2 = new Integer(value);
          show("new Integer()", r1, r2);
          Integer v1 = Integer.valueOf(value); // 3 使用valueOf()
          Integer v2 = Integer.valueOf(value);
          show("Integer.valueOf()", v1, v2);
          int x = value; // 4 基本类型
          int y = value;
          System.out.println("Primitive int");
          System.out.printf("%d==%d %b%n", x, y, x == y);
      }

      public static void main(String[] args) {
          test(127);
          test(128);
      }
  }
  /* output : 
  Automatic:
  127==127 true true
  new Integer():
  127==127 false true
  Integer.valueOf():
  127==127 true true
  Primitive int
  127==127 true
  Automatic:
  128==128 false true
  new Integer():
  128==128 false true
  Integer.valueOf():
  128==128 false true
  Primitive int
  128==128 true
  */
  ```

- 代码说明：
  - 在`test()`中，整数值对象以4种不同的方式创建。
    1. 自动转换为Integer。 实际是通过 `Integer.valueOf()` 的自动调用来完成的。
    2. 使用`new`菜创建Integer对象。**注意：Java 9 已经弃用，建议使用 Integer.valueOf()**；
    3. 从Java 9 开始，valueOf()优于【2】。
    4. 基本类型int也可以当作整数值对象使用。

> **对于参数值127来说**， 出于效率原因，Integer会通过享元模式（Flyweight Pattern，主要用于减少创建对象的数量，以减少内存占用和提高性能。 这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。 享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。）来缓存范围在 -128~127内的对象，因此多次调用Integer.value(127)生成的其实是同一个对象。

## 4.7. 逻辑操作符

- 逻辑操作符“与”（&&）、“或”（||） 和“非”（!）可以根据参数的逻辑关系，生成一个true或false的布尔值。

- *“与”、“或”、“非”操作只可应用于布尔值。不能将逻辑表达中将一个非布尔值当作布尔值使用。*
- *可以将int类型替换成除boolean类型外的其他任何基本数据类型。*

### 4.7.1. 短路

- 逻辑操作符支持一种称为“短路”的现象。一旦表达式当前部分的计算结果能够明确无误地确定整个表达式的值，表达式余下部分就不会被执行了。

## 4.8. 字面量

- 一般来说，如果程序里使用了一个字面量（literal value）,则编译器能准确地知道它是什么类型的。不然当类型模棱两可的时候，你就必须使用该字面量相关的一些字符，以此添加额外信息来引导编译器。

| 类型     | 开头   | 结尾 | 举例        |
| -------- | ------ | ---- | ----------- |
| 十六进制 | 0x     |      | 0x2f、 0x2F |
| 八进制   | 0      |      | 0177        |
| 二进制   | 0b或0B |      | 0b00110101  |
| long     |        | l或L | 1l、 1L     |
| float  |        | f或F | 1f、1L      |
| double  |        | d或D | 1d、1D      |

- Java 7 引入了二进制字面量，通过前缀0b或0B来表示；

### 4.8.1. 字面量里的下划线

- Java7中增加的新功能：可以在数字字面量里使用下划线，这样更易于阅读。

``` java
double d = 341_435_936.445_667;
int bin = 0b0010_1111_1010_1111;
```

- 这里有几条合理的规则：
  1. 只能使用单个下划线，不能连续使用多个；
  2. 数字的开头或结尾不能有下划线；
  3. 想F、D或L这样的后缀周围不能有下划线；
  4. 在二进制或十六进制标识符b和x的周围不能有下划线。

### 4.8.2. 科学记数法（又称“指数记数法”）

- 例如：`float f4 = 1e-43f;`

## 4.9. 按位操作符

- 按位操作符用来操作整数基本数据类型中的单个二进制位（bit）。按位操作符会对两个参数重对应的二进制位执行布尔代数运算，并生成一个结果个。

- `按位与 &` : 如果两个输入位都是1，则按位“与”操作符（&）生成一个输出位1，否则生成一个输出位0。
  
  ``` java
  // 按位与 &
  // a     => 00001101
  // b     => 00001010
  // a & b => 00001000
  ```

- `按位或 |` : 两个输入位里只要有一个是1，那么按位“或”操作符（|）就会生成一个输出位1，只有在两个输入位都是0的情况下，它才会生成一个输出位0。
  
  ``` java
  // 按位或 |
  // a     => 00001101
  // b     => 00001010
  // a | b => 00001111
  ```

- `按位异或 ^` : 如果两个输入位里**只有一个**是1，那么按位“异或”操作符（^）会生成一个输出位1。
  
  ``` java
  // 按位异或 ^
  // a     => 00001101
  // b     => 00001010
  // a ^ b => 00000111
  ```

- `按位非 ，取反 ~` : 按位“非”操作符（~）也称为**取反**操作符，它是`一元操作符`，只对一个操作数进行操作（其他按位操作符都是二元操作符）。按位“非”操作符生成与输入位相反的值 —— 若输入位位0，则输出位位1；若输入位为1，则输出位为0；
  
  ``` java
  // 按位非 ，取反 ~
  // a  => 00001101
  // ~a => 11110010
  ```

> 注意：按位操作符可与等号（=）联合使用，来合并运算和赋值操作：`&=`、`|=`和`^=` 都是合法的（`~`是一元操作符，所以不能与等号联合使用）。

## 4.10. 位移操作符

- 移位操作符也操作二进制位，它们只能用来处理基本类型锂的**整数类型**。

- `左移位操作符（<<）` : 左移位操作符（<<）会将操作符左侧的操作数向左移动，移动的位数载操作符右侧指定（低位补0）；

  ``` java
  // 0B1111      : 00000000000000000000000000001111 
  // 0B1111 << 2 : 00000000000000000000000000111100
  ```

- `"有符号"的右位移操作符（>>）` : 则按照操作符右侧指定的位数将操作符左侧的操作数向右移动。“有符号”的右移操作符使用了“符号扩展”：如果符号为正，则在高位插入0，否则在高位插入1。

  ``` java
  // 15      : 00000000000000000000000000001111 
  // 15 >> 2 : 00000000000000000000000000000011

  // -1      : 11111111111111111111111111111111 
  // -1 >> 2 : 11111111111111111111111111111111
  ```

- `"无符号"的右位移操作符（>>>）` : 它使用“零扩展”：无论符号为正还是为负，都在高位插入0.

  ``` java
  // -1       : 11111111111111111111111111111111 
  // -1 >>> 2 : 00111111111111111111111111111111
  ```

- 移位操作符可以与等号组合使用（<<=、>>= 或 >>>=）。操作符左边的值会移动右边指定的位数，然后再将得到的结果赋给左边的变量。

> 注意：如果char、byte或者short类型的数值进行移位运算，在位移操作前它们会被转换为int类型，并且结果也是int类型。

## 4.11. 三元操作符

- `三元操作符`也叫`条件操作符`，它笔记特别，因为有桑操作数。不过它的确是操作符，因为它最终会生成一个结果值。

``` java
boolean-exp ? value0 : value1
```

- 如果 boolean-exp 运行的结果为true，value0就会被执行，其结果会被当作这个三元操作符的结果值。
- 如果 boolean-exp 运行的结果为false，value1s就会被执行，其结果会被当作这个三元操作符的结果值。

## 4.12. 字符串操作符 + 和 +=

- Java中的字符串操作符有一种特殊用法：正如你所看到的那样，`+`和`+=`操作符都可以连接字符串。

- 如果表达式以一个字符串开头，则其后的所有操作数都必须是字符串类型的（编译器会自动把双引号里的字符串序列转换成字符串）；

``` java
public class StringOperators {
    public static void main(String[] args) {
        int x = 0, y = 1, z = 2;
        String s = "x, y, z ";
        System.out.println(s + x + y + z); // x, y, z 012
        // 将 x 转为字符串
        System.out.println(x + " " + z); // 0 2
        s += "(summed) = "; // 拼接操作
        System.out.println(s + (x + y + z));
        // Integer.toBinaryString() 的简化版：
        System.out.println("" + x);
    }
}
```

## 4.13. 使用操作符时常犯的错误

- 极其常见的错误如下所示：

``` java
while(x = y){

}
```

在这里，程序员显然是想测试是否相等（==）而不是赋值。在Java中，这个表达式的执行结果不是boolean类型，但编译器需要一个boolean 类型。而且因为Java中无法将int类型转为boolean类型，所以编译器会直接显示一个编译的错误，让你在运行程序之前就能发现问题。因此，这种错误在Java中不会发生。（唯一不会得到编译时错误的情况是x和y都是boolean类型，此时x=y是一个合法的表达式，而且前面示例中，这可能是一个错误。）

## 4.14. 类型转换操作符

- `类型转换`的英文单词（case）原意有“浇筑模具”的意思。在适当的时候，Java会自动将一种类型的数据更改为另一种类型的数据。

``` Java
public class Casting {
    public static void main(String[] args) {
        int i = 200;
        long lng = (long) i;
        lng = i; // 宽化，因此不需要强制转换类型
        long lng2 = (long) 200;
        lng2 = 200;
        // 一个窄化转型
        i = (int) lng2; // 需要强制类型转换
    }
}
```

- 在Java中，类型转换则比较安全。不给，执行被称为`窄化转型（narrowing conversion）`的操作时，就有可能面临信息丢失的危险。窄化转型就是说，将能容纳更多信息的数据类型转换成无法容纳那么多信息的数据类型。此时，编译器会要求我们进行强制类型转换，意在提醒我们：“这可能是一个危险的操作，如果的确要这么做，你必须显示地进行类型转换”。而对于`宽化类型（widening conversion）`，则不必显示地进行类型转换，因为新类型可以容纳比原来的类型更多的信息，而不会造成任何信息的丢失。

> 注意：Java可以把任何基本类型转换成别的基本类型，但boolean除外，它不允许进行任何类型的转换处理。

### 4.14.1. 截尾和舍入

- 在执行窄化转型时，必须注意截尾与舍入问题。将float或double转型为整型值时，总时对该数值执行截尾。

### 4.14.2. 提升

- 如果对于小于int类型的基本数据类型（即char、byte或者short）执行算术运算或按位运算，运算执行前这些值就会被自动提升位int，结果也是int类型。如果要把结果赋值给较小的类型，就必须使用强制类型转换（由于把值赋给了较小的类型，可能会出现信息丢失）。通常，表达式里出现的最大的数据类型决定了表达式最终结果的数据类型。如果将一个float类型的值与一个double类型的值相乘，结果就是double类型。如果将一个int值和一个long值相机，则结果为long类型。

## 4.15  Java没有 sizeOf()

- 在C和C++中，sizeOf()操作符会告诉你给数据项分配的字节数。Java不需要sizeOf()操作符来处理可移植性，因为所有的数据类型在所有机器中的大小都是相同的。

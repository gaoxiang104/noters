# 15. 异常

- [15. 异常](#15-异常)
  - [15.0. 引言](#150-引言)
  - [15.1. 概念](#151-概念)
  - [15.2. 基本的异常](#152-基本的异常)
  - [15.3. 异常捕获](#153-异常捕获)
    - [15.3.1. try 块](#1531-try-块)
    - [15.3.2. 异常处理程序](#1532-异常处理程序)
  - [15.4. 创建自己的异常](#154-创建自己的异常)
    - [15.4.1. 异常与日志记录](#1541-异常与日志记录)
  - [15.5. 异常说明](#155-异常说明)
  - [15.6. 捕捉任何异常](#156-捕捉任何异常)
  - [15.6.1. 多重捕捉](#1561-多重捕捉)
    - [15.6.2. 栈轨迹](#1562-栈轨迹)
    - [15.6.3. 重新抛出异常](#1563-重新抛出异常)
      - [15.6.3.4. 精确地重新抛出异常](#15634-精确地重新抛出异常)
    - [15.6.4. 异常链](#1564-异常链)
  - [15.7. 标准 Java 异常](#157-标准-java-异常)
    - [15.7.1. 特例：RuntimeException](#1571-特例runtimeexception)
  - [15.8. 新特性：更好的 NullPointerException 报告机制](#158-新特性更好的-nullpointerexception-报告机制)
  - [15.9. 使用 finally 执行清理](#159-使用-finally-执行清理)

## 15.0. 引言

- 改进错误恢复机制是增加代码稳健性的最强有力的方法之一。

- 捕捉错误的理想时机是在编译时，也就是在你试图运行程序之前。然而，并不是所有的错误都能在编译时发现。其他问题必须在运行时通过某种正规手段来处理，这种手段应该支持这个错误的源头将适当的信息传递给知道如何正确处理该难题的某个接受者。

- **要创建一个稳定的系统，每个组建都必须是稳健的**。

- Java 使用异常提供了一个一致的错误报告模型，从而使组件可以将问题可靠地传达给客户代码；

- 在 Java 中，异常处理的目标时减少当前的代码量，从而使创建大型、可靠的程序更简单易行，并且这样也使我们更加确信，应用程序不会存在未处理的错误。异常不是特别难学，而且可以为我们的项目提供直接和显著的好处。

## 15.1. 概念

- `异常（exception）` 这个词在英语中有 “感到意外” 的意思。当问题出现时，我们可能不知道如何处理，但是我们知道，我们不能愉快地继续下去了 —— 我们必须停下来，而某个人活某个地方必须想办法解决问题。但是在当前的上下文中，我们没有足够的信心来解决这个问题。所以我们把问题提交给更上层的上下文，那里有人能做出正确的决策。

## 15.2. 基本的异常

- `异常情形（exceptional condition）` 是指阻止当前方法或作用域继续执行的问题。
  
  - 当抛出一个异常时，会发生几件事。首先，异常对象会被创建出来，这一点和任何 Java 对象都一样：使用 `new` 创建，放在堆上。当前执行路径停止，指向这个异常对象的引用被从当前上下文推出来。现在异常处理机制接管控制，并开始寻找可以继续执行这个程序的适当位置。这个适当位置就是 “异常处理程序” ，它的工作是从问题中恢复，这样程序才能要么尝试另一条路径，要么继续执行。

  - 通过创建一个表示我们的信息的对象，并将其“抛”出当前上下文，我们可以将关于这个错误的信息发送到一个更大的上下文中。这叫作 **抛出异常** ，如下所示：

    ``` java
    throw new NullPointerException();
    ```

  - 异常使得我们可以把自己所做的每件事情都看作一个事务，而异常可以为这些事物提供保护：“。。。在分布式计算中需要异常处理，这个事物的基本前提。事物等同于计算机中的合同法。如果有任何地方出了问题，我们将放弃整个计算。“ 我们也可以把异常看作一个内置的 ”撤销（undo）“ 系统，因为可以在程序中小心地设置各种恢复点。如果程序的某个地方出了问题，异常可以实现 “撤销” ，回到程序中某个已知的稳定点。

- `异常参数`

  - 和 Java 中的任何对象一样，我们总是使用 `new` 在堆上创建异常，它会分配存储空间并调用构造器。所有标准异常类都有两个构造器：<u>*第一个时无参构造器；第二个接受一个 `String` 参数，用于在异常中放置相关信息。*</u>

    ``` java
    throw new NullPointerException("t == null");
    ```

  - 关键字 `throw` 会产生激光有趣的结果。在用 `new` 创建一个异常对象后，我们把生成的引用交给了 `throw` 。这个对象实际上是从方法中“返回”的，尽管其类型通常不是我们设计让这个方法返回的。一个简单的方法是把异常处理看成是另一种返回机制，虽然类比走得太远也会有麻烦。我们也可以通过抛出一个异常来退出正常的作用域。不管是哪种情况，都会返回一个异常对象，并退出当前的方法或作用域。

  - `Throwable` 是异常类型的根类；

## 15.3. 异常捕获

- 要弄清楚如何捕捉异常，首先必须理解 `被守护区域（guarded region）` 的概念。这是一段可能会产生异常的代码，后面跟着处理这些异常的代码。

### 15.3.1. try 块

- 如果我们正处于一个方法之中，并抛出了异常，该方法将在抛出异常的过程中退出。如果不希望退出，可以在其中设置一个特殊的块来捕获这个异常。因为要在这里“尝试”各种方法调用，所以它称为 `try块`。

``` java
try{
    // 可能会产生异常的代码
}
```

### 15.3.2. 异常处理程序

- 被抛出的异常总是要在某个地方结束。这个 “地方” 就是异常处理程序，我们可以为每种异常类型编写一个。异常处理程序紧跟在 `try` 块之后，用关键字 `catch` 来表示：

``` java
try {
    // 可能会产生异常的代码
} catch (Type1 id1) {
    // 处理 Type1 类型的异常
} catch (Type2 id2) {
    // 处理 Type2 类型的异常
} catch (Type3 id3) {
    // 处理 Type3 类型的异常
}
```

- > 注意：在 `try` 块中，许多不同的方法调用可能会参数相同的异常，但我们只需要一个针对这种类型的处理程序；

- 终止与恢复

  - Java 支持 `终止模型（termination）` ，在这种情况下，我们假设错误是如此严重，以至于无法返回到异常发生的地方。抛出异常的人断定情况已经无法挽回，而且他们也不想再回来；

  - `恢复模型（resumption）`。它意味着异常处理程序有望通过某些工作来修正这种情况，然后重新尝试出现问题的方法，假定第二次可以成功。如果想要使用恢复模型，这意味着我们仍然希望在处理完异常后继续执行。

## 15.4. 创建自己的异常

- 不必拘泥于使用 Java 中已有的异常。 Java 的异常体系无法预见我们可能会遇到的所有错误，所以我们可以创建自己的异常，来表示自己的库可能会遇到的某个特殊问题。

- 要创建自己的异常类，可以继承现有的异常类，最好是与我们要定义的新异常含义接近的。创建一个新的异常类型的最简单方法就是，让编译器为我们创建无参构造器，几乎不需要任何代码。

    ``` java
    class SimpleException extends Exception {
    }
    ```

  - 参考案例：[InheritingExceptions.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/InheritingExceptions.java)

- 还可以创建一个异常类，使其带有接受一个 `String` 参数的构造器

    ``` java
    class MyException extends Exception {
        public MyException() {
            super();
        }

        public MyException(String message) {
            super(message);
        }
    }
    ```

  - 参考案例：[FullConstructors.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/FullConstructors.java)

  - 处理程序中调用了 `Throwable` ( `Exception` 类就是从它继承而来的 ) 的一个方法： `printStackTrace()` 。 如输出所示，这会输出到达异常发生点点方法调用序列的信息。在这里，这些信息被发送到了 `System.out` ，并自动地被捕获和显示在输出中。然而，如果调用默认的版本：`e.printStackTrace()` ;

### 15.4.1. 异常与日志记录

- 我们可以使用 `java.util.logging` 工具将输出记录到 `日志` 中。基本的日志记录操作很简单，如下演示：

  - 参考案例：[LoggingExceptions.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/LoggingExceptions.java)

- `LoggingExceptions` 用到的方法非常方便，因为它把所有的日志继承设施都构建在类异常类本身之中，因此它可以自动工作，无须客户程序员干预。然而，更常见的情况是捕捉别人的异常，并将其记录到日志中，所以我们必须在异常处理程序中生成日志信息；
  - 参考案例：[LoggingExceptions2.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/LoggingExceptions2.java)

- 创建自己的异常的过程还可以更进一步。我们可以添加更多构造器和成员。
  - 参考案例：[MyFeatures.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/MyFeatures.java)

## 15.5. 异常说明

- Java 需要用语法礼貌地告知客户程序员这个方法会抛出的异常，这样客户程序员可以处理它们。这就是 `异常说明（exception specification）`；<u>*它是方法声明的组成部分，出现在参数列表之后*</u>。

    ``` java
    void f() throws TooBig, TooSmall, DivZero { }
    ```

- 异常说明必须和实际情况匹配。如果方法中的代码引发了异常，但是这个方法并没有处理，编译器就会检测到并提醒我们：要么处理这个异常，要么用异常说明指出这个异常可能会从该方法中抛出。通过自上而下地强制实施异常说明，Java 保证在编译时可以提供一定程度的异常正确性。

- 这种在编译时被检查并强制实施的异常叫作 `检查型异常（checked exception）` ；

## 15.6. 捕捉任何异常

- 通过捕捉异常类型的基类 —— `Exception`，可以创建一个能捕捉任何类型异常多处理程序。也存在其他类型的基本异常，不过 `Exception` 是基础，几乎所有的编程活动都与之有关。

    ``` java
    catch (Exception e) {
        System.out.println("Caught an exception");
    }
    ```

- 这会捕捉任何异常，所以如果使用它的话，需要放在处理程序列表的**最后**，以避免它抢在其他任何异常处理程序之前捕获了异常。

- `Exception` 类是所有对程序员很重要的异常类的基类，所以通过它我们不会得到关于异常的很多具体信息，但是我们可以调用来自基类 `Throwable` 的方法。

  - 以下代码用来获取详情信息，或者针对特定区域设置调整过的信息。
    - `String getMessage()`
    - `String getLocalizedMessage()`
  - 以下代码返回 `Throwable` 的简短描述
    - `String toString()`
  - 以下代码打印 `Throwable` 和 `Throwable` 的调用栈轨迹。
    - `void printStackTrace()`
    - `void printStackTrace(PrintStream)`
    - `void printStackTrace(java.io.PrintWriter)`
  - 以下代码在这个 `Throwable` 对象中记录栈帧的当前状态信息。当应用会重新抛出错误或异常时很有用。
    - `Throwable fillInStackTrace()`

- 下面的示例演示了 `Exception` 类的基本方法。

  - [ExceptionMethods.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/ExceptionMethods.java)

## 15.6.1. 多重捕捉

- 如果我们想以同样的方式处理一组异常，并且它们有一个共同的基类，那么直接捕获这个基类即可。但是如果它们没有共同的基类，在 Java 7 之前，必须为每一个异常写一个 `catch` 子句。

  - [SameHandler.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/SameHandler.java)

- 利用 Java 7 提供的多重捕获（multi-catch）处理程序，我们可以在一个 `catch` 子句中用 “|” 操作符把不同类型的异常连接起来：

    ``` java
    public class MultiCatch2 {
        void x() throws Except1, Except2, Except3, Except4 { }

        void process() { }

        void f() {
            try {
                x();
            } catch (Except1 | Except2  e) {
                process();
            } catch (Except3 | Except4 e) {
                process();
            }
        }
    }
    ```

### 15.6.2. 栈轨迹

- `printStackTrace()` 提供的信息也可以使用 `getStackTrace()` 直接访问。这个返回会返回一个由栈轨迹元素组成的数组，美国元素表示一个栈桢。元素 0 是栈顶，而且它是序列中的最后一个方法调用 （这个 Throwable 被创建和抛出的位置）。数组中的最后一个元素和栈底则是序列中的第一个方法调用。下面是一个简单的演示。

  - [WhoCalled.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/WhoCalled.java)

### 15.6.3. 重新抛出异常

- 有时候我们重新抛出刚捕获的异常，特别是当使用 `Exception` 来捕获任何异常的时候。我们已经有指向当前异常的引用，所以可以重新抛出他：

``` java
catch(Exception e) {
    System.out.println("An exception was thrown");
    throw e;
}
```

- 重新抛出一个异常，会导致它进入邻近的更上层上下文中的异常处理程序。对应于同一个 try 块后面的 catch 自居仍然会被忽略。此外，关于这个异常对象的所有信息都会被保留下来，所以在更上层的上下文中捕获具体异常类型的处理程序，可以从这个对象中提取所有信息。

#### 15.6.3.4. 精确地重新抛出异常

- 在 Java 7 之前，如果我们捕获了一个异常，那么只能重新抛出这种类型的异常。这会导致代码中出现不精确的问题，Java 7 已修复了。所以在 Java 7 之前，以下代码是无法通过编译的。

    ``` java
    class BaseException extends Exception { }
    class DerivedException extends BaseException { }

    public class PreciseRethrow {
        void catcher() throws DerivedException {
            try {
                throw new DerivedException();
            } catch (BaseException e) {
                throw e;
            }
        }
    }
    ```

### 15.6.4. 异常链

- 有时我们会捕捉一个异常并抛出另一个，但仍然保留原始异常的信息，这称为 `异常链` 。在 Java 1.4 之前，程序员要自己编写代码来保留原始异常的信息，但现在所有的 `Throwable` 子类都可以选择在构造器中接受一个 `cause` 对象（ `Throwable(String msg, Throwable cause)` ）。 这个 `cause` 意在作为原始的异常，尽管我们正在创建和抛出一个新异常，但是通过将它传进去，我们可以维护能追溯到源头的栈轨迹。

- 在 `Throwable` 的子类中，只有三种基本的异常类提供了带 `cause` 参数的构造器，它们是 `Error（JVM使用它来报告系统错误）`、`Exception` 和 `RuntimeException` 。要链接任何其他的异常，请使用 `initCause()` 方法而不是构造器。

- 演示案例：[DynamicFields.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/DynamicFields.java)

## 15.7. 标准 Java 异常

- Java 类 `Throwable` 描述了任何可以被当作异常抛出的事物。有两个常用的继承自 `Throwable` 的类型：`Error` 和 `Exception` 。前者代表的是编译时错误和系统错误，除了个别极特殊的情况，我们不用关心其捕获。后者是一个基本类型，可以从任何标准的 Java 库方法、我们的方法以及运行时事故中抛出。所以，Java 程序员最关心的基本类型通常是 `Exception` 。

- 重要的是理解异常这个概念以及如何处理这些异常。<u>*基本思路是，异常的名字代表了所发生的问题，所以它应该是不言而喻的。*</u>

### 15.7.1. 特例：RuntimeException

- `RuntimeException` 代表的是编程错误，它包括以下错误：
  - 无法预料的错误，比如在外面控制之外的 `null` 引用。
  - 作为程序员，应该在代码中检查的错误（比如看到 `ArrayIndexOutOfBoundsException` ，我们就应该注意数组的大小了）。在一个地方发生的异常，往往会变成另一个地方的问题。

- 我们从来不会在异常说明里说一个地方可能会抛出 `RuntimeException` （或者任何继承自 `RuntimeException` 的类型），因为它们是 **`“非检查型异常”（unchecked exception）`** 。因为它们指出的是 `bug` ，会被自动处理，所以我们通常不用捕获 `RuntimeException` 。如果你必须坚持 `RuntimeException` 的话，你的代码就会变得非常乱。尽管我们通常不用捕获 `RuntimeException` ，但是在自己的包中，我们有可能选择抛出某个 `RuntimeException` 。

- 演示案例：[NeverCaught.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/NeverCaught.java)

## 15.8. 新特性：更好的 NullPointerException 报告机制

- `NullPointerException` 有个令人沮丧的问题：当我们遇到这种情况是，能看到的信息不多。`JDK 15` 敲定了更好的 `NullPointerException` 报告机制。考虑如下示例，`null` 被插入一个对象链条中：

  - 演示案例：[BetterNullPointerReports.java](./code/src/main/java/pers/xgo/onjava/chapter15_exceptions/BetterNullPointerReports.java)

  - 当使用 `JDK 8` 编译并运行时，几乎没什么信息：

    ``` java
    null
    java.lang.NullPointerException
    java.lang.NullPointerException
    ```

  - 然而使用 `JDK 15` 或更高版本，可以看到：

    ``` java
    null
    java.lang.NullPointerException: Cannot read field "s" because "c.b.a" is null
    java.lang.NullPointerException: Cannot read field "a" because "c.b" is null
    ```

## 15.9. 使用 finally 执行清理

- 往往会出现这样的情况：不管 `try` 块中是不是抛出异常，都有一段代码必须执行。为了达到这个效果，我们可以在所有异常处理程序的末尾使用一个 `finally` 子句。所以，异常处理的全貌就是下面这样：

    ``` java
    try {
        // 被守护区域：可能会抛出 A、B 或 C 的危险活动
    } catch(A a) {
        // 情况 A 的处理程序
    } catch(B b) {
        // 情况 B 的处理程序
    } catch(C c) {
        // 情况 c 的处理程序
    } finally {
        // 不管哪样情况都要执行的活动
    }
    ```

> 注意：`finally` 子句总会执行！


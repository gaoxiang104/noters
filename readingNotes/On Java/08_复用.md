# 8. 复用

- [8. 复用](#8-复用)
  - [8.1. 组合用法](#81-组合用法)
    - [8.1.1. toString() 方法](#811-tostring-方法)
    - [8.1.2. @Override 注解](#812-override-注解)
  - [8.2. 继承语法](#82-继承语法)
    - [8.2.1. 初始化基类](#821-初始化基类)
    - [8.2.2. 带参构的构造器](#822-带参构的构造器)
  - [8.3. 委托](#83-委托)
  - [8.4. 组合与继承相结合](#84-组合与继承相结合)
    - [8.4.1. 确保正确的清理](#841-确保正确的清理)
    - [8.4.2. 名称隐藏](#842-名称隐藏)
  - [8.5. 选择组合还是继承](#85-选择组合还是继承)
  - [8.6. protected 关键字](#86-protected-关键字)

## 8.1. 组合用法

- 我们在前面的示例中已经多次使用了`组合`，将对象引用放在新类中即可。

- 编译器并不是简单地为每个引用创建一个默认对象，这一点是合理的，因为这在需要情况下会产生不必要的开销。初始化引用有下列4种方式：
  1. 定义对象时。这意味着它们将始终在调用构造器之前被初始化
  2. 在该类的构造器中；
  3. 在对象实际使用之前。这通常称为延迟初始化（lazy initialization）。在对象创建成本高昂且不需要每次都创建的情况下，它可以减少开销。
  4. 使用实例初始化。

### 8.1.1. toString() 方法

- 每个非基本类型的对象都有一个`toString()`方法；
- 当编译器需要一个字符串，但有的是一个对象时，将通过`toString()`方法来将对象变成一个字符串；

### 8.1.2. @Override 注解

- 注解@Override，来让编译器确保我们实现了正确的重写；
- @Override是可选的，但它有助于验证有没有拼写错误（或更详细地说，有没有拼错大小写），或有没有犯一些其他的常见错误。

## 8.2. 继承语法

- 继承是所有面向对象语言不可或缺的一个组成部分；
- <u>其实当创建一个类时，总是在继承。除非明确指定了要继承某个类，否则将隐式继承Java的`标准根类 Object`</u>；

- 当继承时，表示”*<u>这个新类就像那个旧类</u>*“；

- 需要在类主体的左花括号之前声明这一点，这通过关键字 extends 以及后面跟着的 `基类` 名称来实现。这样做时，会自动获得基类的所有字段和方法

- Java 提供了 `super` 关键字，来代指当前类继承的“超类”（基类）。因此，表达式 `super.scrub()` 调用了基本版本的 `scrub()` 方法。

- 在继承时，并不局限于只使用基类的方法。还可以向子类中添加新方法，其方式与在类中添加任意方法一样：只需要定义它即可；

### 8.2.1. 初始化基类

- 当创建子类对象时，它里面包含了一个基类的子对象（subobject）。这个子对象与直接通过基类创建的对象时一样的。

- 正确初始化基类的子对象至关重要，我们只有一种方式可以保证这一点：*<u>在子类构造器中调用基类构造器来执行初始化，它具有执行基类初始化所需要的全部信息和权限。</u>*；

- *<u>Java会自动在子类构造器中插入对基类构造器的调用；</u>*

``` java
// 继承时调用构造器
class Art { // 艺术
    Art() {  System.out.println("Art constructor"); }
}

class Drawing extends Art { // 绘画
    Drawing() { System.out.println("Drawing constructor"); }
}

public class Cartoon extends Drawing { // 卡通
    Cartoon() { System.out.println("Cartoon constructor"); }

    public static void main(String[] args) {
        Cartoon x = new Cartoon();
    }
}
/* OUTPUT : 
Art constructor
Drawing constructor
Cartoon constructor
 */
```

- 构造器是从基类“向外”进行的，因此基类在子类构造器可以访问之前就被初始化了。
- 子类没有创建构造器，编译器也会为它合成一个可以调用基类构造器的无参构造器。

### 8.2.2. 带参构的构造器

- 如果基类没有无参构造器，或者如果你必须要调用具有参数的基类构造器，那么就要使用`super`关键字和相应的参数列表，来显式调用基类构造器；例如：

``` java
// 继承、构造器和参数
class Game{
    Game(int i){ System.out.println("Game constructor"); }
}
class BoardGame extends Game{ // 棋盘游戏
    BoardGame(int i){
        super(i);
        System.out.println("BoardGame constructor");
    }
}
public class Chess extends BoardGame{ // 国际象棋
    Chess(){
        super(11);
        System.out.println("Chess constructor");
    }

    public static void main(String[] args) {
        Chess x = new Chess();
    }
}
```

- 如果不在BoardGame 的构造器中显示调用基类的构造器，编译器会报错，它表示找不到形式为 `Game()`的构造器。

- *<u>对基类构造器的调用必须是子类构造器的第一个操作（否则编译器会通过报错来提示）</u>*。

## 8.3. 委托

- 虽然Java里没有提供直接支持，但除了组合和继承外，还有第三种关系叫做`委托（delegation）`。它介于继承和组合之间，之所以这么说是因为将成员对象放在构建的类中（类似组合），但同时又在新类里公开了成员对象的所有方法（类似继承）。例如：

``` java
// SpaceShipControls.java
public class SpaceShipControls { // 太空船控制
    void up(int velocity){}
    void down(int velocity){}
    void left(int velocity){}
    void right(int velocity){}
    void forward(int velocity){}
    void back(int velocity){}
    void turboBoost(){}
}

// DerivedSpaceShip.java
public class DerivedSpaceShip extends SpaceShipControls { // 衍生太空船
    private String name;
    public DerivedSpaceShip(String name) {
        this.name = name;
    }
    @Override
    public String toString() { return name; }

    public static void main(String[] args) {
        DerivedSpaceShip protector = new DerivedSpaceShip("NSEA Protector");
        protector.forward(100);
    }
}

```

- DerivedSpaceShip 并非真正的 SpaceShipControls 类型，即使可以 “告诉” 一个 DerivedSpaceShip 调用 forward() 方法。 更准确地说，一艘太空船中包含了 SpaceShipControls , 同时 SpaceShipControls 中的所有方法都在太空船中暴露给了外部。

## 8.4. 组合与继承相结合

- 经常同时用到组合和继承；

### 8.4.1. 确保正确的清理

- 在清理方法中，还需要注意基类与成员对象两者之间清理方法的调用顺序，以防止某个子类对象依赖于另一个。首先执行自己的类的所有特定清理工作，其顺序同创建顺序相反。（这通常要求基类元素仍然存活。）然后调用基类的清理方法。

``` java
public void dispose(){
  t.dispose();
  c.dispose();
  super.dispose(); // 最后清理
}
```

### 8.4.2. 名称隐藏

- 如果Java基类的方法名称被多次重载，则在子类中重新定义该方法名称不会隐藏任何基类版本。无论方法时在子类还是在基类中定义，重载都有效。

## 8.5. 选择组合还是继承

- 当希望在新类中使用现有类的功能而不是其接口时，应该使用组合。
- 当使用继承时，你通过现有的类来生成它的一个特殊版本。这通常意味着对通用类进行定制，使它可以用于特定需求。

- *<u>**继承用来表示 `is-a` 关系的，而组合时用来表示 `has-a` 关系的**</u>*；

## 8.6. protected 关键字

- `protected` 关键字是对实用主义的一个认可。它像是在说：“就类的用户而言，这是private的，但对继承该类的任何类或同一包中的其他类来说，它是可用的。”（protected 还提供包访问权限。）

- 尽管可用创建 `protected` 字段，但最好的方法是将字段设置为 `private`，并始终保留更改底层实现的权利。然后通过 `protected` 方法来控制继承者的访问权限。
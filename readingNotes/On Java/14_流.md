# 14. 流

- [14. 流](#14-流)
  - [14.0. 引用](#140-引用)
  - [14.1. Java 8 对流的支持](#141-java-8-对流的支持)
  - [14.2. 流的创建](#142-流的创建)
    - [14.2.1. 随机数流](#1421-随机数流)
    - [14.2.2. int类型的区间范围](#1422-int类型的区间范围)
    - [14.2.3. generate()](#1423-generate)

## 14.0. 引用

> 集合优化了对象的存储。而 `流（stream）` 与对象的成批处理有关；

- `流` 是一个与任何特定的存储机制没有关系的元素序列。事实上，我们说流“没有存储”；

- 不同于在集合中遍历元素，使用流的时候，我们是从一个管道中抽取元素，并对它们进行操作。这些管道通常会被串联到一起，形成这个流的一个操作管线。

- 流的一个核心优点是，它们能使我们的程序更小，也更好理解。当配合流使用时，`lambda表达式` 和 `方法引用` 就发挥出其威力了。流大大提升了 `Java 8` 的吸引力。

- 例如，假设我们想按照有序方式显示随机选择 5～20 范围内的，不重复的 int 数。因为要它们进行排序，所以我们可能会把注意力放在选择一个有序的集合上，并基于这样的集合来解决问题。但是借助流，只需要说吗想做什么即可：

    ``` java
    public class Randoms {
        public static void main(String[] args) {
            new Random(47)
                    .ints(5, 20)
                    .distinct()
                    .limit(7)
                    .sorted()
                    .forEach(System.out::println);
        }
    }
    ```

  - `ints()` 方法会生成一个`流`，该方法有多个重载版本，其中两个参数的版本可以设置所生成值的上下界。这里生成了一个由随机的 `int` 组成的 `流`；
  - 我们使用 **中间流操作** `distinct()` 去掉重复的值；再使用 `limit()` 选择前 7 个值；然后使用 `sorted()` 进行排序；
  - 最后，使用 `forEach()` ，会根据我们传递的函数，在每个流对象上执行操作。我们这里使用 `System.out::println` 来显示每一个条目；

- **`声明式编程`** 是一种编程风格，我们说明想要完成 **`什么（what）`** ，而不是指明 **`怎么做（how）`** ，这就是我们在函数式编程中看到的。显然命令式编程理解起来要更困难：

    ``` java
    public class ImperativeRandoms {
        public static void main(String[] args) {
            Random rand = new Random(47);
            SortedSet<Integer> rints = new TreeSet<>();
            while (rints.size() < 7) {
                int r = rand.nextInt(20);
                if (r < 5) continue;
                rints.add(r);
            }
            System.out.println(rints);
        }
    }
    ```

  - 在 `Randoms.java` 中，我们根本不需要定义任何变量，但是这里有 3 个变量：rand，rints 和 r 。`nextInt()` 没有设置下界的喧嚣，这使得代码更复杂了：它内置的下界总是零，所以不可避免会生成额外的值，我们也就不得不将那些小于 5 的从中过滤掉；

  - 不难发现，我们必须仔细研究这段代码，才能弄清楚到底发生了什么，而在 `Randoms.java` 中，代码就 **告诉** 了我们它在做什么。这种清晰的表达是应该使用 `Java 8` 的 `流` 的最有说服力的原因之一。

  - 像在 `ImperativeRandoms.java` 中这样显示地编写迭代机制，称为 **`外部迭代`** 。 而在 `Randoms.java` 中，我们看不到任何这样的机制，所以被称为 **`内部迭代`** ，这是流编程的一个核心特性。

- > 流的另一个重要方面是 **`惰性求值`** ，这意味着它们只在绝对必要时才会被求值。我们可以把流想象成一个 “延迟列表” 。 因为 **延迟求值**，所以流使用我们可以表示非常大的（甚至是无限大的）序列，而不用考虑内存问题；

## 14.1. Java 8 对流的支持

- Java 的设计者们面临一个难题。它们有一套现有的库，不仅用在了 Java 库本身之中，还用在了用户编写的无数代码之中。他们如何将流这个新的基本概念整合到现有的库中的呢？

- `Java 8` 引入的解决方案是接口中的 **`默认方法（default）`** ，有了默认方法，Java 的设计者们可以将流方法硬塞进现有的类中，而且他们几乎把我们可以能需要的每个操作都添加进去了。

- 这些操作可分为三种类型：
  - 创建流
  - 修改流元素（**中间操作**）
  - 消费流（**终结操作**）；最后一种类型的操作往往意味着收集一个流的元素（通常是将其放进某个集合）。

## 14.2. 流的创建

- 使用 `Stream.of()` ， 可以轻松地将一组条目变成一个流：

    ``` java
    public class StreamOf {
        public static void main(String[] args) {
            record Bubble(Integer i) { }

            Stream.of(new Bubble(1), new Bubble(2), new Bubble(3))
                    .forEach(System.out::println);

            Stream.of("It's ", "a ", "wonderful ", "day ", "for ", "pie")
                    .forEach(System.out::print);

            System.out.println();

            Stream.of(3.14159, 2.718, 1.618)
                    .forEach(System.out::println);
        }
    }
    ```

- 此外，每个 `Collection` 都可以使用 `stream()` 方法来生成一个流：

    ``` java
    public class CollectionToStream {
        public static void main(String[] args) {
            record Bubble(Integer i) {
            }

            List<Bubble> bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));
            System.out.println(
                    bubbles.stream()
                            .mapToInt(b -> b.i)
                            .sum()
            );

            Set<String> w = new HashSet<>(Arrays.asList("It's a wonderful day for pie!".split(" ")));
            w.stream()
                    .map(x -> x + " ")
                    .forEach(System.out::print);
            System.out.println();

            Map<String,Double> m = new HashMap<>();
            m.put("pi",3.14159);
            m.put("e",2.718);
            m.put("phi",1.618);
            m.entrySet().stream()
                    .map(e -> e.getKey() + " : " + e.getValue())
                    .forEach(System.out::println);
        }
    }
    ```

  - 中间 `map()` 操作接受流中的每个元素，在其上应用一个操作来创建一个新的元素，然后将这个新元素沿着流继续传递下去。普通的 `map()` 接受对象并生成对象，但是当希望流输出持有的数值类型是，`map()` 还有一些特殊的版本。这里 `mapToInt()` 将一个对象流变成了一个包含 `Integer` 的 `IntStream` 。对于 `Float` 和 `Double` ，也有名字类似的操作。

  - 为了从 `Map集合` 生成一个流，我们首先调用 `entrySet()` 来生成一个对象流，其中每个对象都包含着一个 `键` 和与其关联的 `值`，然后再使用 `getKey()` 和 `getValue()` 将其分开。


### 14.2.1. 随机数流

- `Random` 类已经得到增强，有一组可以生成流的方法：

    ``` java
    public class RandomGenerators {
        public static <T> void show(Stream<T> stream) {
            stream.limit(4)
                    .forEach(System.out::println);
            System.out.println("++++++++");
        }

        public static void main(String[] args) {
            Random random = new Random(47);
            show(random.ints().boxed());
            show(random.longs().boxed());
            show(random.doubles().boxed());
            // 控制上下边界：
            show(random.ints(10,20).boxed());
            show(random.longs(50 ,100).boxed());
            show(random.doubles(20,30).boxed());
            // 控制流的大小
            show(random.ints(2).boxed());
            show(random.longs(2).boxed());
            show(random.doubles(2).boxed());
            // 控制流的大小和边界
            show(random.ints(3,3,9).boxed());
            show(random.longs(3,12,22).boxed());
            show(random.doubles(3,11.5,12.3).boxed());
        }
    }
    ```

- `Stream.generate()` ，它可以接受任何的 `Supplier<T>`，并生成一个由 `T` 类型的对象组成的流。

    ``` java
    public class RandomWords implements Supplier<String> {
        List<String> words = new ArrayList<>();
        Random random = new Random(47);
        RandomWords(String fname) throws IOException{
            List<String> lines = Files.readAllLines(Paths.get(fname));
            // 跳过第一行
            for (String line : lines.subList(1, lines.size())) {
                for (String word : line.split("[ .?,]+")) { // 解析单词
                    words.add(word.toLowerCase());
                }
            }
        }
        @Override
        public String get() {
            return words.get(random.nextInt(words.size()));
        }

        @Override
        public String toString() {
            return words.stream().collect(Collectors.joining(" "));
        }

        public static void main(String[] args) throws IOException {
            System.out.println(
                    Stream.generate(new RandomWords("Cheese.dat"))
                            .limit(10)
                            .collect(Collectors.joining(" "))
            );
        }
    }
    ```

  - 在 `toString()` 和 `main()` 中可以看到 `collect()` 操作，它会根据其参数将所有的流元素组合起来。当我们使用 `Collectors.joining()` 时，得到的结果是一个 `String`，每个元素都会以 `joining()` 的参数分隔。还有其他很多 `Collectors`，可以生成不同的结果。

### 14.2.2. int类型的区间范围

- `IntStream` 类提供了一个 `range()` 方法，可以生成一个流 —— 由 `int` 值组成的序列。这编写循环时非常方便：

    ``` java
    public class Ranges {
        public static void main(String[] args) {
            // 传统方式
            int result = 0;
            for (int i = 10; i < 20; i++) {
                result += i;
            }
            System.out.println(result);

            // for-in 搭配一个区间范围：
            result = 0;
            for (int i : IntStream.range(10, 20).toArray()) {
                result += i;
            }
            System.out.println(result);

            // 使用流
            System.out.println(IntStream.range(10, 20).sum());
        }
    }
    ```

- 为了取代简单的 `for` 循环，这里有一个自定义的 `repeat()` 工具函数： 
  - [Repeat.java](./code/src/main/java/pers/xgo/onjava/chapter14_streams/Repeat.java)

### 14.2.3. generate()

- `RandomWords.java` 用到了 `Supplier<T>` 和 `Stream.generate()` 。下面是第二个示例：

    ``` java
    public class Generator implements Supplier<String> {
        Random random = new Random(47);
        char[] letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".toCharArray();

        @Override
        public String get() {
            return ""+letters[random.nextInt(letters.length)];
        }

        public static void main(String[] args) {
            String word = Stream.generate(new Generator())
                    .limit(30)
                    .collect(Collectors.joining());
            System.out.println(word);
        }
    }
    ```

- 如果想创建一个由`完全相同`的对象组成的流，只需要将一个生成这些对象的 `lambda表达式` 传给 `generate()` ：

    ``` java
    public class Duplicator {
        public static void main(String[] args) {
            Stream.generate(() -> "duplicate")
                    .limit(3)
                    .forEach(System.out::println);
        }
    }
    ```

- 或者可以传入一个与 `Supplier<T>` 接口兼容的方法引用：

    ``` java
    public class Bubbles {
        public static void main(String[] args) {

            record Bubble(int i){ // 定义一个 Bubble 类
                private static int count = 0;
                public static Bubble bubbler(){
                    return new Bubble(count++);
                }
            }

            Stream.generate(Bubble::bubbler)
                    .limit(5)
                    .forEach(System.out::println);
        }
    }
    /* OUTPUT :
    Bubble[i=0]
    Bubble[i=1]
    Bubble[i=2]
    Bubble[i=3]
    Bubble[i=4]
    */
    ```

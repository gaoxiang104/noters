# 14. 流

- [14. 流](#14-流)
  - [14.0. 引用](#140-引用)
  - [14.1. Java 8 对流的支持](#141-java-8-对流的支持)
  - [14.2. 流的创建](#142-流的创建)

## 14.0. 引用

> 集合优化了对象的存储。而 `流（stream）` 与对象的成批处理有关；

- `流` 是一个与任何特定的存储机制没有关系的元素序列。事实上，我们说流“没有存储”；

- 不同于在集合中遍历元素，使用流的时候，我们是从一个管道中抽取元素，并对它们进行操作。这些管道通常会被串联到一起，形成这个流的一个操作管线。

- 流的一个核心优点是，它们能使我们的程序更小，也更好理解。当配合流使用时，`lambda表达式` 和 `方法引用` 就发挥出其威力了。流大大提升了 `Java 8` 的吸引力。

- 例如，假设我们想按照有序方式显示随机选择 5～20 范围内的，不重复的 int 数。因为要它们进行排序，所以我们可能会把注意力放在选择一个有序的集合上，并基于这样的集合来解决问题。但是借助流，只需要说吗想做什么即可：

    ``` java
    public class Randoms {
        public static void main(String[] args) {
            new Random(47)
                    .ints(5, 20)
                    .distinct()
                    .limit(7)
                    .sorted()
                    .forEach(System.out::println);
        }
    }
    ```

  - `ints()` 方法会生成一个`流`，该方法有多个重载版本，其中两个参数的版本可以设置所生成值的上下界。这里生成了一个由随机的 `int` 组成的 `流`；
  - 我们使用 **中间流操作** `distinct()` 去掉重复的值；再使用 `limit()` 选择前 7 个值；然后使用 `sorted()` 进行排序；
  - 最后，使用 `forEach()` ，会根据我们传递的函数，在每个流对象上执行操作。我们这里使用 `System.out::println` 来显示每一个条目；

- **`声明式编程`** 是一种编程风格，我们说明想要完成 **`什么（what）`** ，而不是指明 **`怎么做（how）`** ，这就是我们在函数式编程中看到的。显然命令式编程理解起来要更困难：

    ``` java
    public class ImperativeRandoms {
        public static void main(String[] args) {
            Random rand = new Random(47);
            SortedSet<Integer> rints = new TreeSet<>();
            while (rints.size() < 7) {
                int r = rand.nextInt(20);
                if (r < 5) continue;
                rints.add(r);
            }
            System.out.println(rints);
        }
    }
    ```

  - 在 `Randoms.java` 中，我们根本不需要定义任何变量，但是这里有 3 个变量：rand，rints 和 r 。`nextInt()` 没有设置下界的喧嚣，这使得代码更复杂了：它内置的下界总是零，所以不可避免会生成额外的值，我们也就不得不将那些小于 5 的从中过滤掉；

  - 不难发现，我们必须仔细研究这段代码，才能弄清楚到底发生了什么，而在 `Randoms.java` 中，代码就 **告诉** 了我们它在做什么。这种清晰的表达是应该使用 `Java 8` 的 `流` 的最有说服力的原因之一。

  - 像在 `ImperativeRandoms.java` 中这样显示地编写迭代机制，称为 **`外部迭代`** 。 而在 `Randoms.java` 中，我们看不到任何这样的机制，所以被称为 **`内部迭代`** ，这是流编程的一个核心特性。

- > 流的另一个重要方面是 **`惰性求值`** ，这意味着它们只在绝对必要时才会被求值。我们可以把流想象成一个 “延迟列表” 。 因为 **延迟求值**，所以流使用我们可以表示非常大的（甚至是无限大的）序列，而不用考虑内存问题；

## 14.1. Java 8 对流的支持

- Java 的设计者们面临一个难题。它们有一套现有的库，不仅用在了 Java 库本身之中，还用在了用户编写的无数代码之中。他们如何将流这个新的基本概念整合到现有的库中的呢？

- `Java 8` 引入的解决方案是接口中的 **`默认方法（default）`** ，有了默认方法，Java 的设计者们可以将流方法硬塞进现有的类中，而且他们几乎把我们可以能需要的每个操作都添加进去了。

- 这些操作可分为三种类型：
  - 创建流
  - 修改流元素（**中间操作**）
  - 消费流（**终结操作**）；最后一种类型的操作往往意味着收集一个流的元素（通常是将其放进某个集合）。

## 14.2. 流的创建

- 使用 `Stream.of()` ， 可以轻松地将一组条目变成一个流：

    ``` java
    public class StreamOf {
        public static void main(String[] args) {
            record Bubble(Integer i) { }

            Stream.of(new Bubble(1), new Bubble(2), new Bubble(3))
                    .forEach(System.out::println);

            Stream.of("It's ", "a ", "wonderful ", "day ", "for ", "pie")
                    .forEach(System.out::print);

            System.out.println();

            Stream.of(3.14159, 2.718, 1.618)
                    .forEach(System.out::println);
        }
    }
    ```

- 此外，每个 `Collection` 都可以使用 `stream()` 方法来生成一个流：

    ``` java
    public class CollectionToStream {
        public static void main(String[] args) {
            record Bubble(Integer i) {
            }

            List<Bubble> bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));
            System.out.println(
                    bubbles.stream()
                            .mapToInt(b -> b.i)
                            .sum()
            );

            Set<String> w = new HashSet<>(Arrays.asList("It's a wonderful day for pie!".split(" ")));
            w.stream()
                    .map(x -> x + " ")
                    .forEach(System.out::print);
            System.out.println();

            Map<String,Double> m = new HashMap<>();
            m.put("pi",3.14159);
            m.put("e",2.718);
            m.put("phi",1.618);
            m.entrySet().stream()
                    .map(e -> e.getKey() + " : " + e.getValue())
                    .forEach(System.out::println);
        }
    }
    ```

  - 中间 `map()` 操作接受流中的每个元素，在其上应用一个操作来创建一个新的元素，然后将这个新元素沿着流继续传递下去。普通的 `map()` 接受对象并生成对象，但是当希望流输出持有的数值类型是，`map()` 还有一些特殊的版本。这里 `mapToInt()` 将一个对象流变成了一个包含 `Integer` 的 `IntStream` 。对于 `Float` 和 `Double` ，也有名字类似的操作。

  - 为了从 `Map集合` 生成一个流，我们首先调用 `entrySet()` 来生成一个对象流，其中每个对象都包含着一个 `键` 和与其关联的 `值`，然后再使用 `getKey()` 和 `getValue()` 将其分开。
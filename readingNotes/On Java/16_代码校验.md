# 16. 代码校验

- [16. 代码校验](#16-代码校验)
  - [16.1. 测试](#161-测试)
    - [16.1.1. 单元测试](#1611-单元测试)
      - [16.1.1.1. JUnit](#16111-junit)
    - [16.1.2. 测试覆盖率的幻觉](#1612-测试覆盖率的幻觉)

> 你永远无法保证自己的代码是正确的。你只能证明自己的代码存在问题。

## 16.1. 测试

- 如果没有经过测试，代码就不能正常工作。

- Java 大体上是一门静态类型语言，程序员通兑这种语言提供的显式安全性过于放心，认为“如果编译器没有提示错误，那就没问题”。但是静态类型检查时一种非常有限的测试类型，它仅仅意味着编译器接受代码的语法和基本类型规则，并不意味着代码满足了程序的目标。当你获得更多编程经验后，会了解到自己的代码机会永远无法满足这些目标。代码验证的第一步就是`创建测试`，来检查代码行为是否满足你的目标。

### 16.1.1. 单元测试

- 这是一个将集成测试到你创建的所有代码里的过程，并在每次构建系统时运行这些测试。这样，构建过程不仅可以检查语法错误，还可以检查语义错误。

- 这里的“ `单元` ”表明测试的事一小段代码。通常，每个类都有测试，检查它所有方法的行为。而 “系统” 测试则不同，它检查已完成的程序是否满足了最终要求。

#### 16.1.1.1. JUnit

- JUnit 通过使用反射和注解极大地改进了自身，并大大简化了编写单元测试的过程。而使用 Java 8 之后，JUnit 甚至添加了对 `lambda` 表达式的支持。

- 在 JUnit 的最简单用法中，可以使用 `@Test` 注解来表示测试的每个方法。 JUnit 将这些方法识别为单独的测试，每次设置和运行一个，并采取措施来避免测试之间相互影响。

- 让我们尝试一个简单的示例。`CountedList` 继承了 `ArrayList` ，并添加了一些信息来跟踪 `CountedList` 的创建数量：

    ``` java
    // 跟踪自身创建的数量
    import java.util.ArrayList;
    public class CountedList extends ArrayList<String> {
        private static int counter = 0;
        private int id = counter++;

        public CountedList() {
            System.out.println("CountedList #" + id);
        }

        public int getId() {
            return id;
        }
    }
    ```

  - 编写测试代码：[CountedListTest.java](./code/src/test/java/pers/xgo/onjava/chapter16_validating/CountedListTest.java)

  - `@BeforeAll` 注解标注的方法会在任何测试执行之前运行一次。 `@AfterAll` 注解标注的方法在所有测试执行之后运行一次。<u>*两种方法都是必须是**静态**的*</u>。

  - `@BeforeEach` 注解标注的方法通常用于创建和初始化一组公共对象，<u>*并在每次测试之前运行*</u>。你也可以将这些初始化操作放在测试类的构造器中，不过我认为 `@BeforeEach` 更清晰。`JUnit` 为每个测试创建一个对象，以确保运行的测试之间没有副作用。<u>*不过，所有测试对应的全部对象都是提前一次性创建的（而不是在测试运行之前创建）*</u>，所以使用 `@BeforeEach` 和 构造器之间的唯一区别是，`@BeforeEach` 在测试之前才被调用。在大多数情况下，这不是问题，如果你愿意，也可以使用构造器方法。

  - 如果在每次测试后必须执行清理（比如需要恢复修改过的 `static` 成员，需要关闭打开的文件、数据库或网络连接等），请使用 `@AfterEach` 注解来标注方法。

  - JUnit 使用 `@Test` 注解来标注这些方法，并将每个方法作为测试运行。在这些方法中，你可以执行任何所需要的操作，并使用 JUnit 的`断言方法`（均以名称 `assert` 开头）来严重测试的正确性（在 JUnit 文档中可以找到所有的 “assert” 语句）。如果断言识别，则会显示导致失败的表达式和值。

  - 断言语句不是必需的，也可以在没有断言的情况下运行测试，如果没有异常，就可以认为测试是成功的。

### 16.1.2. 测试覆盖率的幻觉

- `测试覆盖率（test coverage）`，也称为 `代码覆盖率（code coverage）` ，是衡量代码库的测试百分比。百分比越高，测试覆盖率越大。

> 对于没有相关知识但处于控制地位的人来说，很容易做出只接受覆盖率为 100% 的决定。这是有问题的，因为这个数字并不是衡量测试有效的合理标准。你可能测试了所有需要测试的内容，但只达到 65% 的测试覆盖率。如果有人要求 100% 的覆盖率，那么你就会在其余部分浪费大量时间，并且在以后向项目添加代码时浪费时间。
>
> 当分析未知的代码库时，测试覆盖率作为粗略的衡量标准非常有用。如果覆盖率工具报告的值特别低（例如，小于 40% ），则表明覆盖率可能不足。然而，一个非常高的值同样是可疑的，这表明对编程领域知识不足的人强迫团队做出了武断的决定。覆盖工具的最佳用途是发现代码库中未经测试的部分。但是，不要依赖覆盖率来获取测试质量相关的信息。
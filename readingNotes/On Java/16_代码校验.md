# 16. 代码校验

- [16. 代码校验](#16-代码校验)
  - [16.1. 测试](#161-测试)
    - [16.1.1. 单元测试](#1611-单元测试)
      - [16.1.1.1. JUnit](#16111-junit)
    - [16.1.2. 测试覆盖率的幻觉](#1612-测试覆盖率的幻觉)
  - [16.2. 前置条件](#162-前置条件)
    - [16.2.1. 断言](#1621-断言)
      - [16.2.1.1. Java断言语法](#16211-java断言语法)
      - [16.2.1.2. Guava 里的断言](#16212-guava-里的断言)
      - [16.2.1.3. 在契约式设计中使用断言](#16213-在契约式设计中使用断言)
      - [16.2.1.4. 检查指令](#16214-检查指令)
      - [16.2.1.5. 前置条件测试](#16215-前置条件测试)
      - [16.2.1.6. 后置条件](#16216-后置条件)
      - [16.2.1.7. 不变项](#16217-不变项)
      - [16.2.1.8. 放宽 DbC 限制](#16218-放宽-dbc-限制)
      - [16.2.1.8. 放宽 DbC 的限制](#16218-放宽-dbc-的限制)

> 你永远无法保证自己的代码是正确的。你只能证明自己的代码存在问题。

## 16.1. 测试

- 如果没有经过测试，代码就不能正常工作。

- Java 大体上是一门静态类型语言，程序员通兑这种语言提供的显式安全性过于放心，认为“如果编译器没有提示错误，那就没问题”。但是静态类型检查时一种非常有限的测试类型，它仅仅意味着编译器接受代码的语法和基本类型规则，并不意味着代码满足了程序的目标。当你获得更多编程经验后，会了解到自己的代码机会永远无法满足这些目标。代码验证的第一步就是`创建测试`，来检查代码行为是否满足你的目标。

### 16.1.1. 单元测试

- 这是一个将集成测试到你创建的所有代码里的过程，并在每次构建系统时运行这些测试。这样，构建过程不仅可以检查语法错误，还可以检查语义错误。

- 这里的“ `单元` ”表明测试的事一小段代码。通常，每个类都有测试，检查它所有方法的行为。而 “系统” 测试则不同，它检查已完成的程序是否满足了最终要求。

#### 16.1.1.1. JUnit

- JUnit 通过使用反射和注解极大地改进了自身，并大大简化了编写单元测试的过程。而使用 Java 8 之后，JUnit 甚至添加了对 `lambda` 表达式的支持。

- 在 JUnit 的最简单用法中，可以使用 `@Test` 注解来表示测试的每个方法。 JUnit 将这些方法识别为单独的测试，每次设置和运行一个，并采取措施来避免测试之间相互影响。

- 让我们尝试一个简单的示例。`CountedList` 继承了 `ArrayList` ，并添加了一些信息来跟踪 `CountedList` 的创建数量：

    ``` java
    // 跟踪自身创建的数量
    import java.util.ArrayList;
    public class CountedList extends ArrayList<String> {
        private static int counter = 0;
        private int id = counter++;

        public CountedList() {
            System.out.println("CountedList #" + id);
        }

        public int getId() {
            return id;
        }
    }
    ```

  - 编写测试代码：[CountedListTest.java](./code/src/test/java/pers/xgo/onjava/chapter16_validating/CountedListTest.java)

  - `@BeforeAll` 注解标注的方法会在任何测试执行之前运行一次。 `@AfterAll` 注解标注的方法在所有测试执行之后运行一次。<u>*两种方法都是必须是**静态**的*</u>。

  - `@BeforeEach` 注解标注的方法通常用于创建和初始化一组公共对象，<u>*并在每次测试之前运行*</u>。你也可以将这些初始化操作放在测试类的构造器中，不过我认为 `@BeforeEach` 更清晰。`JUnit` 为每个测试创建一个对象，以确保运行的测试之间没有副作用。<u>*不过，所有测试对应的全部对象都是提前一次性创建的（而不是在测试运行之前创建）*</u>，所以使用 `@BeforeEach` 和 构造器之间的唯一区别是，`@BeforeEach` 在测试之前才被调用。在大多数情况下，这不是问题，如果你愿意，也可以使用构造器方法。

  - 如果在每次测试后必须执行清理（比如需要恢复修改过的 `static` 成员，需要关闭打开的文件、数据库或网络连接等），请使用 `@AfterEach` 注解来标注方法。

  - JUnit 使用 `@Test` 注解来标注这些方法，并将每个方法作为测试运行。在这些方法中，你可以执行任何所需要的操作，并使用 JUnit 的`断言方法`（均以名称 `assert` 开头）来严重测试的正确性（在 JUnit 文档中可以找到所有的 “assert” 语句）。如果断言识别，则会显示导致失败的表达式和值。

  - 断言语句不是必需的，也可以在没有断言的情况下运行测试，如果没有异常，就可以认为测试是成功的。

### 16.1.2. 测试覆盖率的幻觉

- `测试覆盖率（test coverage）`，也称为 `代码覆盖率（code coverage）` ，是衡量代码库的测试百分比。百分比越高，测试覆盖率越大。

> 对于没有相关知识但处于控制地位的人来说，很容易做出只接受覆盖率为 100% 的决定。这是有问题的，因为这个数字并不是衡量测试有效的合理标准。你可能测试了所有需要测试的内容，但只达到 65% 的测试覆盖率。如果有人要求 100% 的覆盖率，那么你就会在其余部分浪费大量时间，并且在以后向项目添加代码时浪费时间。
>
> 当分析未知的代码库时，测试覆盖率作为粗略的衡量标准非常有用。如果覆盖率工具报告的值特别低（例如，小于 40% ），则表明覆盖率可能不足。然而，一个非常高的值同样是可疑的，这表明对编程领域知识不足的人强迫团队做出了武断的决定。覆盖工具的最佳用途是发现代码库中未经测试的部分。但是，不要依赖覆盖率来获取测试质量相关的信息。

## 16.2. 前置条件

- **`前置条件（precondition）`** 的概念来自 **`契约式设计（Design By Contract, DbC）`** ，并使用了基本的 **`断言（assertion）`** 的机制来实现。本节中我们首先查看 Java 中的断言，然后介绍 DbC，最后以 `Google Guava` 库为例来讲解。

### 16.2.1. 断言

- **`断言`** 通过验证程序执行期间是否满足某些条件来提高程序的稳健性。

- 例如，假设在对象中有一个数值字段表示儒略历上的月份。我们知道此值必须始终在 1～12 范围内。断言可以检查这一点，并在它超出该范围时报告错误。如果在方法内部，则可以使用断言来检查参数的有效性。这些都是确保程序正确的重要测试，但他们不能在编译时检查，也不属于但愿测试的范围。

#### 16.2.1.1. Java断言语法

- Java 断言语句有两种形式：

    ``` java
    assert boolean-expression;
    assert boolean-expression : information-expression;
    ```

  - 两者都表示 “我断言这个 boolean-expression 的值是 true”。如果不是这种情况，则断言会产生一个 `AssertionError` 异常。它是 `Throwable` 的一个子类，因此不需要指定异常规范；
  - 但是第一种断言形式产生的异常不包含 boolean-expression 的任何信息；所以可以加上 `information-expression` ，就可以在异常栈里生成一个有用的消息。

  - 案例1:

    ``` java
    public class Assert1 {
        public static void main(String[] args) {
            assert false;
        }
    }
    ```

  - 案例2:

    ``` java
    public class Assert2 {
        public static void main(String[] args) {
            assert false : "Here's a message saying what happened";
        }
    }
    ```

- 还可以根据类名或包名打开和关闭断言，也就是说，可以为整个包启用或禁用断言。

- 还有另一个方法可以控制断言：以编程的方式操作 `ClassLoader` 对象。`ClassLoader` 中有几种方法允许动态启用和禁用断言，包括 `setDefaultAssertionStatus()` ，它为之后加载的所有类设置了断言状态。所以可以像下面这样静默地开启断言： 

    ``` java
    public class LoaderAssertions {
        public static void main(String[] args) {
            ClassLoader.getSystemClassLoader().setDefaultAssertionStatus(true);
            new Loaded().go();
        }
    }

    class Loaded {
        public void go() {
            assert false : "Loaded.go()";
        }
    }
    ```

- 在程序运行时再决定是否启用断言也是有道理的。可以使用以下静态子句完成此操作，该子句放置在系统的主类中：

    ``` java
    static {
        boolean assertionsEnabled = false;
        // 注意，此处的赋值副作用时故意造成的：
        assert assertionsEnabled = true;
        if(!assertionsEnabled){
            throw new RuntimeException("Assertions disabled");
        }
    }
    ```

#### 16.2.1.2. Guava 里的断言

- 启用 Java 原生的断言很麻烦，因此 `Guava` 团队添加了一个 `Verify类` ，提供了始终启用的替换断言。它们建议静态导入 `Verify 方法` ：

    ``` java
    import static com.google.common.base.Verify.*;

    public class GuavaAssertions {
        public static void main(String[] args) {
            verify(2 + 2 == 4);

            try {
                verify(1 + 2 == 4);
            } catch (Exception e) {
                System.out.println(e);
            }

            try {
                verify(1 + 2 == 4, "Bad math");
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }

            try {
                verify(1 + 2 == 4, "Bad math: %s", "not 4");
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }

            String s = "";
            s = verifyNotNull(s);
            s = null;

            try {
                verifyNotNull(s);
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }

            try {
                verifyNotNull(s, "Shouldn't be null : %s", "arg s");
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
        }
    }
    ```

  - 这里有两个方法，`verify()` 和 `verifyNotNull()` ，它们各自有变种方法可以提供错误消息。
  - 注意，`verifyNotNull()` 的内置错误消息通常就足够了，而 `verify` 则过于笼统，无法提供有用的默认错误消息。

#### 16.2.1.3. 在契约式设计中使用断言

- **`契约式设计（DbC）`** 是一个概念，通过保证对象遵循某些规则来创建稳健的程序。这些规则由药解决问题的性质决定，而这超出了编译器可以验证的范围。

- `DbC` 假定服务提供者与该服务的消费者或客户之间存在着明确指定的合同。在面向对象编程中，服务通常由对象提供，对象的边界 —— 提供者和消费者之间的分界 —— 是对象所属类的接口。当客户调用特定的公共方法时，它们期望该调用会产生某些特定的行为：对象中状态的更改，或可预测的返回值。这种行为的设计主旨概括如下：
  - 可以明确规定这种行为，就好像合同一样；
  - 可以通过某些运行时检查来保证这种行为，也就是他所说的**前置条件**，**后置条件** 和 **不变项** ；

#### 16.2.1.4. 检查指令

- 断言也称之为 `指令检查（check instruction）` 。检查指令表明你确信代码运行到某一处时已经有了特定的属性。

#### 16.2.1.5. 前置条件测试

- 前置条件确保客户（即调用此方法的代码）履行其合同部分。这几乎总是意味着在方法调用的最开始（即在该方法执行任何操作之前）检查参数，以确保它们适合在该方法中使用。你永远不知道客户会给你传递什么参数，所以前置条件检查总是一个好主意。

#### 16.2.1.6. 后置条件

- 后置条件会测试方法的执行结果。此代码放置在方法调用的末尾，return 语句之前（如果有的话）。对于长而复杂的方法，如果需要在返回之前验证计算结果（即由于某种原因，你无法总是信任结果），后置条件检查时必不可少的。不过任何时候你都可以提供对方法结果的约束，在代码中将这些约束表示为后置条件时明智的。

#### 16.2.1.7. 不变项

- 不变项保证了对象的状态在方法调用之间是不变的。但是，它并不限制方法在执行期间临时偏离这些保证。它只是说对象的状态信息在以下时间段会始终遵守规定的规则：
  - 进入方法后；
  - 离开方法之前；

#### 16.2.1.8. 放宽 DbC 限制

- 尽管强调了前置条件、后置条件 和 不变项的价值，以及在开发过程中使用这些工具的重要性，但他也承认在发布的产品中包含所有的 DbC 代码并不总是可行的。可以根据对特定位置代码的信任程度来放宽 DbC 检查。
  - 首先禁用每个方法开头的不变项检查，因为每个方法末尾的不变项检查就可以保证；
  - 当有合理的单元测试来验证方法的返回值时，可以禁用后置条件检查。

#### 16.2.1.8. 放宽 DbC 的限制

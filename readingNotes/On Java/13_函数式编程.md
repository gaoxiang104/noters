# 13. 函数式编程

- [13. 函数式编程](#13-函数式编程)
  - [13.0. 引言](#130-引言)
  - [13.1. 旧方法和新方式](#131-旧方法和新方式)
  - [13.2. lambda 表达式](#132-lambda-表达式)
    - [13.2.1. 递归](#1321-递归)

## 13.0. 引言

- **`函数式编程（functional programming, FP）`**，通过整合现有代码来产生新的功能，而不是从零开始编写所有内容，由此我们会得到更可靠的代码，而且实现起来更快。这个理论看起来是成立的，至少在某些情况下如此。在发展过程中，函数式语言设计出了优秀的语法，一些非函数式语言也借用了。

- <u>**`面向对象抽象数据，而函数式编程抽象行为。`**</u>

- `纯函数式语言`在安全方面做出了更多努力。它规定了额外的约束条件，即所有的数据比心是<u>**不可变的**</u>：<u>*设置一次，永不改变*</u>。函数会接受值，然后产生新值，但是绝不会修改自身之外的任何东西（包括其参数或该函数作用域之外的元素）。有了这一保证，我们知道不会再有任何由所谓的“副作用” 引起的 bug ，因为函数只创建并返回了一个结果，别的什么都没做。

- 更妙的是，“不可变对象和无副作用”这一编程范式解决了并行编程（当程序的不同部分同时在多个处理器上运行时）中最基本和最棘手的问题之一 —— “可变的共享状态” 问题。 “可变的共享状态” 意味着，运行在不同处理器上的代码的不同部分，可能会同时尝试修改同一块内存（谁会成功？没人知道）。如果函数绝对不会修改现有值，而只是生成新值 —— 这个纯函数式语言的定义 —— 那么就不能存在内存的竞争。因此，纯函数式语言经常被当作并行编程问题的解决方案，当然也有其他可行的解决方案。

## 13.1. 旧方法和新方式

- 通常情况下，方法会根据所传递的数据产生不同的结果。如果想让一个方法在每次调用时都有不同的表现呢？如果将代码传递给方法，就可以控制其行为。

- 以前的做法是，创建一个对象，让它的一个方法包含所需行为，然后将这个对象传递给我们想控制的方法。下面的示例演示了这一点，然后增加了 `Java 8` 的实现方式：`方法引用`和`lambda 表达式`；

``` java
package org.gx.onjava.chapter13_funcational;

interface Strategy { // 策略
    String approach(String msg); // 方法
}

class Soft implements Strategy { // 柔和的策略
    @Override
    public String approach(String msg) {
        return msg.toLowerCase() + "?";
    }
}

class Unrelated { // 不相关的
    static String twice(String msg) { // 两次
        return msg + " " + msg;
    }
}

public class Strategize { // 制定战略
    Strategy strategy; // 策略
    String msg;

    public Strategize(String msg) {
        strategy = new Soft(); // [1]
        this.msg = msg;
    }

    void communicate() { // 交流
        System.out.println(strategy.approach(msg));
    }

    void changeStrategy(Strategy strategy) { // 改变策略
        this.strategy = strategy;
    }

    public static void main(String[] args) {
        Strategy[] strategies = {
                new Strategy() { // [2]
                    @Override
                    public String approach(String msg) {
                        return msg.toUpperCase() + "!";
                    }
                },
                msg -> msg.substring(0, 5), // [3]
                Unrelated::twice // [4]
        };
        Strategize s = new Strategize("Hello there");
        s.communicate();
        for (Strategy newStrategy : strategies) {
            s.changeStrategy(newStrategy); // [5]
            s.communicate(); // [6]
        }
    }
}
/* OUTPUT:
hello there?
HELLO THERE!
Hello
Hello there Hello there
 */
```

- 分析上面代码：
  - [1] 在 `Strategize` 中可以看到，`Soft` 是默认的策略，因为它是在构造器中指定的。
  - [2] 更简洁、自然的方式是创建一个匿名内部类。这样仍然会存在一定数量的重复代码，而且我们总是要花点功夫才能明白这里是在使用匿名内部类。
  - [3] 这是 `Java 8` 的 **`lambda表达式`**，突出的特点是用箭头 `->` 将参数和函数体分隔开来。箭头右边是从 `lambda` 返回的表达。这和类定义及匿名内部类实现了同样的效果，但是代码要少得多。
  - [4] 这是 `Java 8` 的 **`方法引用`**，突出的特点是 `::` 。 `::` 的左边是类名或对象名，右边是方法名，但是没有参数列表。
  - [5] 在使用了默认的 `Soft` 策略之后，我们遍历数组中的所有策略，并使用 `changeStrategy()` 方法将每个策略放入 `s` 中。
  - [6] 现在，每次调用 `communicate()` 都会产生不同的行为，这取决于此时所使用的策略“代码对象”。<u>*我们传递了行为，而不只是传递数据*</u>。

## 13.2. lambda 表达式

- **`lambda 表达式`** <u>*是使用尽可能少的语法编写的函数定义*</u>。

- `lambda` 表达式产生的是函数，而不是类。在 `Java` 的虚拟机（JVM）上，一切都是类，所以幕后会有各种各样的操作，让 `lambda` 看起来像函数。但是作为程序员，我们可以开心地假装它们“就是函数”。

- `lambda` 表达式的语法尽可能宽松，而又恰好使其容易编写和使用。

- 任何 `lambda` 表达式的基本语法如下所示：
  1. 参数；
  2. 后面跟 `->` ，你可以将其读作 “生产（produces）” ；
  3. `->` 后面的都是方法体；

    ``` java
    interface Description { // 描述
        String brief(); // 简明的
    }

    interface Body {
        String detailed(String head); // 详细的
    }

    interface Multi { // 更多
        String twoArg(String head, Double d); // 两参数
    }

    public class LambdaExpressions {
        static Body bod = h -> h + "No parens!"; // [1]
        static Body bod2 = (h) -> h + "More details"; // [2]
        static Description desc = () -> "Short info"; // [3]
        static Multi mult = (h, n) -> h + n; // [4]

        static Description moreLines = () -> { // [5]
            System.out.println("moreLines");
            return "from moreLines()";
        };

        public static void main(String[] args) {
            System.out.println(bod.detailed("Oh! "));
            System.out.println(bod2.detailed("Hi! "));
            System.out.println(desc.brief());
            System.out.println(mult.twoArg("Pi! ", 3.14159));
            System.out.println(moreLines.brief());
        }
    }
    /* OUTPUT:
    Oh! No parens!
    Hi! More details
    Short info
    Pi! 3.14159
    moreLines
    from moreLines()
    */
    ```

- 分析上面代码：
  - [1] 只有一个参数，可以只写这个参数，<u>*不写括号*</u>；
  - [2] 通常情况是用括号将参数包裹起来。为了一致性，在单个参数时可以使用括号，尽管这并不常见；
  - [3] 在没有参数的情况下，<u>**必须**</u>使用括号来指示空的参数列表；
  - [4] 在多个参数的情况下，将它们放在使用括号包裹起来的参数列表内。
  - > 注意，到目前为止，所有 `lambda` 表达式的方法体都是一行。方法体中表达式的结果会自动成为 `lambda` 表达式的发返回值，这里使用 `return` 关键字时不合法的。这是 `lambda` 表达式简化描述功能的语法的又一种体现。
  - [5] 如果 `lambda` 表达式需要多行代码，则必须将这些代码行放到花括号中。这种情况下又需要使用 `return` 从 `lambda` 表达式生成一个值了。

### 13.2.1. 递归

- **递归**意味着一个函数调用了自身。在 `Java` 中也可以编写递归的 `lambda` 表达式，但是有一点要注意：这个 `lambda` 表达式必须被赋值给一个 `静态变量` 或 `实力变量`，否则会出现编译错误。我们分别创建一个示例来说明每种情况：

- 这两个示例都使用了一个同样的接口，其方法接受 `int` 参数，并返回 `int` ：

    ``` java
    public interface IntCall {
        int call(int arg);
    }
    ```

- **`阶乘`**，整数 `n` 的 阶乘` 是所有小于等于 `n` 的正整数的乘积。阶乘函数是一个常见的递归示例：

    ``` java
    public class RecursiveFactorial {
        static IntCall fact; // 因式

        public static void main(String[] args) {
            fact = n -> n == 0 ? 1 : n * fact.call(n - 1);
            for (int i = 0; i < 10; i++) {
                System.out.println(fact.call(i));
            }
        }
    }
    ```

  - > 注意：不能在定义的时候像这样来初始化 fact:

    ``` java
    static IntCall fact = n -> n == 0 ? 1 : n * fact.call(n - 1);
    ```

- **`斐波那契数列`**，这次使用的是实例变量，用构造器来初始化：

    ``` java
    // lambda 实现 斐波那契数列
    public class RecursiveFibonacci {
        IntCall fib;

        RecursiveFibonacci() {
    //        fib = n -> n == 0 ? 0 :
    //                   n == 1 ? 1 :
    //                   fib.call(n - 1) + fib.call(n - 2);
            fib = n -> {
                if (n == 0) return 0;
                if (n == 1) return 1;
                return fib.call(n - 1) + fib.call(n - 2);
            };
        }

        int fibonacci(int n) {
            return fib.call(n);
        }

        public static void main(String[] args) {
            RecursiveFibonacci rf = new RecursiveFibonacci();
            for (int i = 0; i < 10; i++) {
                System.out.println(rf.fibonacci(i));
            }
        }
    }
    ```


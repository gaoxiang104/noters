# 11. 内部类

- [11. 内部类](#11-内部类)
  - [11.1. 创建内部类](#111-创建内部类)
  - [11.2. 到外部类的链接](#112-到外部类的链接)

## 11.1. 创建内部类

- 和你预想的一样，创建内部类的方式就是把类定义放在一个包围它的类之中。

``` java
// 创建内部类
// 返回一个指向内部类的引用
public class Parcel2 {
    class Contents { // 内容
        private int i = 11;

        public int value() {
            return i;
        }
    }

    class Destination { // 目的地
        private String label;

        public Destination(String whereTo) {
            this.label = whereTo;
        }

        String readLabel() {
            return label;
        }
    }

    public Destination to(String  s){
        return new Destination(s);
    }

    public Contents contents(){
        return new Contents();
    }

    // 在 Parcel1 内，使用内部类看上去就和使用任何其他类一样
    public void ship(String dest){ // 运输
        Contents c = new Contents();
        Destination d = new Destination(dest);
        System.out.printf(d.readLabel());
    }

    public static void main(String[] args) {
        Parcel2 p = new Parcel2();
        p.ship("Tasmania");
        Parcel2 q = new Parcel2();
        // 定义指向内部类的引用
        Parcel2.Contents c = q.contents();
        Parcel2.Destination d = q.to("Borneo");
    }
}
/* OUTPUT:
Tasmania
 */
```

- 内部类看上去和普通类没什么不同。表面上唯一的区别是，这些名字都是嵌套在 `Parcel1` 之中的。

- 更普遍的情况是，外部类有一个方法，该方法返回一个指向内部类的引用，正如在 `to()` 和 `contents()` 方法中看到的那样。

- 要在外部类的非静态方法之外的任何地方创建内部类的对象，必须像在 `main()` 中看到的那样，将对象的类型指定为 **<u>`OuterClassName.InnerClassName`</u>** ；

## 11.2. 到外部类的链接

- 当创建一个内部类时，这个内部类的对象会隐含一个链接，指向用于创建对象的外围对象。通过该链接，无须任何特殊条件，内部类对象就可以访问外围对象的成员。此外，内部类拥有对象所有元素的访问权。

``` java
// 保存一个对象序列

interface Selector { // 迭代器
    boolean end(); // 检查是否末尾

    Object current(); // 访问当前

    void next(); // 移动到下一个
}

public class Sequence { // 序列
    private Object[] items;
    private int next = 0;

    public Sequence(int size) {
        items = new Object[size];
    }

    public void add(Object x) { // 添加元素
        if (next < items.length) {
            items[next++] = x;
        }
    }

    private class SequenceSelector implements Selector { // 实现迭代器
        private int i = 0;
        @Override
        public boolean end() {
            return i == items.length;
        }

        @Override
        public Object current() {
            return items[i];
        }

        @Override
        public void next() {
            if (i < items.length) i++;
        }
    }

    public Selector selector(){ // 工厂方法
        return new SequenceSelector();
    }

    public static void main(String[] args) {
        Sequence sequence = new Sequence(10);
        for (int i = 0; i < 10; i++) {
            sequence.add(Integer.toString(i));
        }
        Selector selector = sequence.selector();
        while (!selector.end()){
            System.out.print(selector.current() + " ");
            selector.next();
        }
    }
}
/* OUTPUT:
0 1 2 3 4 5 6 7 8 9
 */
```

- `Sequence` 是以类的形式包装起来的定长 `Object` 数组。可以调用 `add()` 向序列末尾增加一个新的 `Object` （如果还有空间）。要取得 `Sequence` 中的每一个对象，可以使用名为 `Selector` 的接口。
- 这是 **<u>`迭代器（Iterator）设计模式`</u>** 的一个例子。通过 `Selector`，可以检查是否到了 `Sequence` 的末尾（`end()`），访问当前 `Object`（`current()`），以及移动到下一个 `Object`（`next()`）。
- 因为 `Selector` 是一个接口，所以其他类可以用自己的方式实现该接口，而且其他方法可以以该接口为参数，来创建更通用的代码；

- `SequenceSelector` 的创建就和另一个内部类医院。但是仔细研究一些，注意 `end()`、 `current()`、 `next()` 这些方法中的每一个都用到了 `items`，这个引用并不是 `SequenceSelector` 的一部分，而是外围对象的一个 *`private` 字段*。然而，**<u>内部类可以访问外围对象的所有方法和字段</u>**，就好像拥有他们一样。

- 内部类可以自动访问外围类的所有成员。对于负责创建内部类对象的特定外围类对象而言，内部类对象偷偷获取了一个指向它的引用。
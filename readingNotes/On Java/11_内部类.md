# 11. 内部类

- [11. 内部类](#11-内部类)
  - [11.1. 创建内部类](#111-创建内部类)
  - [11.2. 到外部类的链接](#112-到外部类的链接)
  - [11.3. 使用 .this 和 .new](#113-使用-this-和-new)
  - [11.4. 内部类和向上转型](#114-内部类和向上转型)

## 11.1. 创建内部类

- 和你预想的一样，创建内部类的方式就是把类定义放在一个包围它的类之中。

``` java
// 创建内部类
// 返回一个指向内部类的引用
public class Parcel2 {
    class Contents { // 内容
        private int i = 11;

        public int value() {
            return i;
        }
    }

    class Destination { // 目的地
        private String label;

        public Destination(String whereTo) {
            this.label = whereTo;
        }

        String readLabel() {
            return label;
        }
    }

    public Destination to(String  s){
        return new Destination(s);
    }

    public Contents contents(){
        return new Contents();
    }

    // 在 Parcel1 内，使用内部类看上去就和使用任何其他类一样
    public void ship(String dest){ // 运输
        Contents c = new Contents();
        Destination d = new Destination(dest);
        System.out.printf(d.readLabel());
    }

    public static void main(String[] args) {
        Parcel2 p = new Parcel2();
        p.ship("Tasmania");
        Parcel2 q = new Parcel2();
        // 定义指向内部类的引用
        Parcel2.Contents c = q.contents();
        Parcel2.Destination d = q.to("Borneo");
    }
}
/* OUTPUT:
Tasmania
 */
```

- 内部类看上去和普通类没什么不同。表面上唯一的区别是，这些名字都是嵌套在 `Parcel1` 之中的。

- 更普遍的情况是，外部类有一个方法，该方法返回一个指向内部类的引用，正如在 `to()` 和 `contents()` 方法中看到的那样。

- 要在外部类的非静态方法之外的任何地方创建内部类的对象，必须像在 `main()` 中看到的那样，将对象的类型指定为 **<u>`OuterClassName.InnerClassName`</u>** ；

## 11.2. 到外部类的链接

- 当创建一个内部类时，这个内部类的对象会隐含一个链接，指向用于创建对象的外围对象。通过该链接，无须任何特殊条件，内部类对象就可以访问外围对象的成员。此外，内部类拥有对象所有元素的访问权。

``` java
// 保存一个对象序列

interface Selector { // 迭代器
    boolean end(); // 检查是否末尾

    Object current(); // 访问当前

    void next(); // 移动到下一个
}

public class Sequence { // 序列
    private Object[] items;
    private int next = 0;

    public Sequence(int size) {
        items = new Object[size];
    }

    public void add(Object x) { // 添加元素
        if (next < items.length) {
            items[next++] = x;
        }
    }

    private class SequenceSelector implements Selector { // 实现迭代器
        private int i = 0;
        @Override
        public boolean end() {
            return i == items.length;
        }

        @Override
        public Object current() {
            return items[i];
        }

        @Override
        public void next() {
            if (i < items.length) i++;
        }
    }

    public Selector selector(){ // 工厂方法
        return new SequenceSelector();
    }

    public static void main(String[] args) {
        Sequence sequence = new Sequence(10);
        for (int i = 0; i < 10; i++) {
            sequence.add(Integer.toString(i));
        }
        Selector selector = sequence.selector();
        while (!selector.end()){
            System.out.print(selector.current() + " ");
            selector.next();
        }
    }
}
/* OUTPUT:
0 1 2 3 4 5 6 7 8 9
 */
```

- `Sequence` 是以类的形式包装起来的定长 `Object` 数组。可以调用 `add()` 向序列末尾增加一个新的 `Object` （如果还有空间）。要取得 `Sequence` 中的每一个对象，可以使用名为 `Selector` 的接口。
- 这是 **<u>`迭代器（Iterator）设计模式`</u>** 的一个例子。通过 `Selector`，可以检查是否到了 `Sequence` 的末尾（`end()`），访问当前 `Object`（`current()`），以及移动到下一个 `Object`（`next()`）。
- 因为 `Selector` 是一个接口，所以其他类可以用自己的方式实现该接口，而且其他方法可以以该接口为参数，来创建更通用的代码；

- `SequenceSelector` 的创建就和另一个内部类医院。但是仔细研究一些，注意 `end()`、 `current()`、 `next()` 这些方法中的每一个都用到了 `items`，这个引用并不是 `SequenceSelector` 的一部分，而是外围对象的一个 *`private` 字段*。然而，**<u>内部类可以访问外围对象的所有方法和字段</u>**，就好像拥有他们一样。

- 内部类可以自动访问外围类的所有成员。对于负责创建内部类对象的特定外围类对象而言，内部类对象偷偷获取了一个指向它的引用。

## 11.3. 使用 .this 和 .new 

- <u>要生成外部类对象的引用，可以使用外部类的名字，后面加上句点和this</u>。这样生成的引用会自动具有正确的类型，而且是可以再编译时确定并检查的，所以没有任何运行时开销。

``` java
public class DotThis {
    public class Inner {
        public DotThis outer() {
            return DotThis.this;
            // 如果直接写 “this” ，引用的会是 Inner 的 “this”
        }
    }
}
```

- 有时我们想让`其他某个对象`来创建它的某个内部类的对象。要实现这样的功能，可以使用 `.new` 语法，在 `new` 表达式中提供指向其他外部对象的引用，就像下面：

``` java
// 使用 .new 语法直接创建一个内部类的对象
public class DotNew {
    public class Inner {}
    public static void main(String[] args) {
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();
    }
}
```

- 我们要使用 **<u>`外部类的对象`</u>** 来创建`内部类的对象`。

- 除非已经有了一个外部类的对象，否则穿件内部类对象是不可能的。这是因为内部类的对象会暗中连接到用于创建它的外部类对象。然而，如果你创建的是 `嵌套类（static 修饰的内部类）`，它就不需要指向外部类对象的引用。

## 11.4. 内部类和向上转型

- 当需要向上转型为基类，特别是接口时，内部类就更有吸引力了。（从实现某个接口的对象生成一个该接口类型的引用，其效果和向上转型为某个基类在本质是一样的。）这是因为，内部类（接口的实现）对外部而言可以是不可见、不可用的，这便于隐藏实现。外部获得的只是一个指向基类或接口的引用。

``` java
// Contents.java
public interface Contents {
    int value();
}
// Destination.java
public interface Destination {
    String readLabel();
}
// Parcel4.java
public class Parcel4 {
    private class PContents implements Contents {
        private int i = 11;
        @Override public int value() { return i; }
    }

    protected final class PDestination implements Destination {
        private String label;
        private PDestination(String whereTo){
            label=whereTo;
        }
        @Override public String readLabel() { return label; }
    }

    public Destination destination(String s){
        return new PDestination(s);
    }

    public Contents contents(){
        return new PContents();
    }
}
// TestParcel.java
public class TestParcel {
    public static void main(String[] args) {
        Parcel4 p = new Parcel4();
        Contents c = p.contents();
        Destination d = p.destination("Tasmania");
        // 非法 —— 不能访问 private 类
        // Parcel4.PContents pc = p.new PContents();
    }
}
```

- `private` 内部类为类的设计者提供了一种方式，可以完全阻止任何与类型相关的编码依赖，并且可以完全隐藏实现细节。此外，从客户程序员的角度来看，因为午饭访问 `public` 接口之外的任何方法，所以接口的扩展对他们而言并没有什么用处。这也为Java 编译器提供了一个生成更高效代码的机会。
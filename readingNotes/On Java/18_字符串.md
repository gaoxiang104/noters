# 18. 字符串

- [18. 字符串](#18-字符串)
  - [18.1. 不可变的字符串](#181-不可变的字符串)
  - [18.2. 重载 + 与 StringBuilder](#182-重载--与-stringbuilder)
  - [18.3. 无意识的递归](#183-无意识的递归)

## 18.1. 不可变的字符串

- *<u>**`String` 类的对象是不可变的**</u>*。该类中每个看起来会修改 `String` 值的方法，实际上都创建了并返回了一个全新的 `String` 对象，该对象包含了修改的内容。而原始的 `String` 则保持不变。
  
  ``` java
  public class Immutable { // 不变的
      public static String upcase(String s) {
          return s.toUpperCase();
      }

      public static void main(String[] args) {
          String q = "howdy";
          System.out.println(q); // howdy
          String qq = upcase(q);
          System.out.println(qq); // HOWDY
          System.out.println(q); // howdy
      }
  }
  ```

  - 当 `q` 被传递给 `upcase()` 时，实际上传递的是 `q` 对象引用的一个副本。此引用所指向的对象只存在于单一的物理位置中。在传递时被复制的只是引用。

> 对于代码的读者来说，参数一般是给方法提供信息的，而不是要被修改的。这种不变性是一个重要的保证，因为它使代码更易于编写和理解。


## 18.2. 重载 + 与 StringBuilder

- 不变性可能会带来效率问题。一个典型的例子是操作符 `+` ，它针对 `String` 对象做了重载。操作符重载意味着在于特定类一起使用时，相应的操作具有额外的意义。（应用于 `String` 的 `+` 和 `+=` 是 Java 中仅有的被重载的操作符，Java 不允许程序员重载其他操作符。）

- 案例：`+`操作拼接字符串

  ``` java
  public class Concatenation {
      public static void main(String[] args) {
          String mango = "mango";
          String s = "abc" + mango + "def" + 47;
          System.out.println(s);
      }
  }
  ```

- 案例：使用 `StringBuilder` 和 `Stream` 拼接字符串

  ``` java
  public class UsingStringBuilder {
      public static String string1() {
          Random rand = new Random(47);
          StringBuilder result = new StringBuilder("[");
          for (int i = 0; i < 25; i++) {
              result.append(rand.nextInt(100));
              result.append(", ");
          }
          result.delete(result.length() - 2, result.length());
          result.append("]");
          return result.toString();
      }

      public static String string2() {
          String result = new Random(47)
                  .ints(25, 0, 100)
                  .mapToObj(Integer::toString)
                  .collect(Collectors.joining(", "));
          return "[" + result + "]";
      }

      public static void main(String[] args) {
          System.out.println(string1());
          System.out.println(string2());
      }
  }
  ```

- `StringBuilder` 提供了丰富儿全面的方法，包括 `insert()`、`replace()`、`substring()` 甚至 `reverse()`，但我们通常使用的只有 `append()` 和 `toString()` 。注意，*<u>**在添加右方括号之前，可以调用 `delete()` 来删除最后一个逗号和空格。**</u>*

> 结论：当创建 `toString()` 方法时，如果操作很简单，通常可以依赖编译器，让它以合理的方式自行构建结果。但是如果涉及循环，**并且对性能也有一定要求**，那就需要在 `toString()` 中显式使用 `StringBuilder` 了。

## 18.3. 无意识的递归

``` java
public class InfiniteRecursion {
    @Override
    public String toString() {
        return "InfiniteRecursion: " + this + "\n";
    }

    public static void main(String[] args) {
        Stream.generate(InfiniteRecursion::new)
                .limit(10)
                .forEach(System.out::println);
    }
}
/* ERROR:
Exception in thread "main" java.lang.StackOverflowError
 */
```

- **`自动类型转换`**，例如：`"InfiniteRecursion: " + this`
  - 编译器看到一个 `String` 后面跟着一个 `+` 和一个不是 `String` 的东西，它就试图将这个 `this` 转换为一个 `String` 。这个转换是通过调用 `toString()` 来完成的，而这样就产生了一个递归调用。最后导致栈溢出；
  - 如果真想打印对象的地址，可以直接调用 `Object` 的 `toString()` 方法来实现。
# 第9章 接口

- [第9章 接口](#第9章-接口)
  - [9.1 抽象类和抽象方法](#91-抽象类和抽象方法)
  - [9.2 接口](#92-接口)
  - [9.3 完全解藕](#93-完全解藕)
  - [9.4 Java中的多重继承](#94-java中的多重继承)
  - [9.5 通过继承来扩展接口](#95-通过继承来扩展接口)
    - [9.5.1 组合接口时的名字冲突](#951-组合接口时的名字冲突)
  - [9.6 适配接口](#96-适配接口)
  - [9.7 接口中的域](#97-接口中的域)
    - [9.7.1 初始化接口中的域](#971-初始化接口中的域)
  - [9.8 嵌套接口](#98-嵌套接口)
  - [9.9 接口与工厂](#99-接口与工厂)
  - [9.10 总结](#910-总结)

> 接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法。

## 9.1 抽象类和抽象方法

抽象类，它是普通的类与接口之间的一种中庸之道。

Java提供一种叫做`抽象方法`的机制，这种方法是不完整的；仅有声明而没有方法体。下面是抽象方法声明所采用的语法：

``` java
abstract void f();
```

包含抽象方法的类叫做`抽象类`。如果一个类爆红一个或多个抽象方法，该类必须被限定为**抽象类**。（否则编译器就会报错。）

抽象类的作用和特点：

1. 由于为抽象类创建对象是不安全的，所以我们会从编译器那里得到一条错误消息。这样，编译器会确保抽象类的纯粹性，我们不必担心会误用它。
2. 如果从一个抽象类继承，并想创建该新类的对象，那么就必须为基类中的所有抽象方法提供方法定义。如果不这样做（可以选择不这样做），那么导出类便也是抽象类，且编译器将会强制我们用`abstract`关键字来限定这个类。
3. 我们也可能会创建一个没有任何抽象方法的抽象类。考虑这种情况：如果一个类，让其包含任何abstract方法都显得没有实际意义，而且我们也想要阻止产生这个类的任何对象，那么这时这样做久很有用了。

第8章Instrument类可以很容易地转化成abstract类。既然使某个类成为抽象类并不需要所有的方法都是抽象的，所以仅需将某些方法声明为抽象的即可。如下图：

<img src="./images/9/1.png" alt="" align=center />

***

``` java
enum Note {
    MIDDLE_C, C_SHARP, B_FLAT;
}
abstract class Instrument {
    abstract void play(Note n);
    abstract void adjust();
    String what() { return "Instrument"; }
}
class Wind extends Instrument {
    @Override
    void play(Note n) {  System.out.println("Wind.play()" + n); }
    @Override
    void adjust() { System.out.println("Adjusting Wind"); }
    @Override
    String what() { return "Wind"; }
}
class Percussion extends Instrument {
    @Override
    void play(Note n) { System.out.println("Percussion.play()" + n); }
    @Override
    void adjust() { System.out.println("Adjusting Percussion"); }
    @Override
    String what() { return "Percussion"; }
}
class Stringed extends Instrument {
    @Override
    void play(Note n) { System.out.println("Stringed.play()" + n); }
    @Override
    void adjust() { System.out.println("Adjusting Stringed"); }
    @Override
    String what() { return "Stringed"; }
}
class Woodwind extends Wind {
    @Override
    void play(Note n) { System.out.println("Woodwind.play()" + n); }
    @Override
    String what() { return "Woodwind"; }
}
class Brass extends Wind {
    @Override
    void play(Note n) { System.out.println("Brass.play()" + n); }
    @Override
    void adjust() { System.out.println("Adjusting Brass"); }
}
public class Music4 {
    static void tune(Instrument i) { i.play(Note.C_SHARP); }
    static void tuneAll(Instrument[] e) { for (Instrument i : e) { tune(i); } }
    public static void main(String[] args) {
        Instrument[] orchestra = {
                new Wind(), new Percussion(), new Stringed(),
                new Brass(), new Woodwind()
        };
        tuneAll(orchestra);
    }
}
/* output
Wind.play()C_SHARP
Percussion.play()C_SHARP
Stringed.play()C_SHARP
Brass.play()C_SHARP
Woodwind.play()C_SHARP
 */
```

创建抽象类和抽象方法非常有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用它们。抽象类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动。

## 9.2 接口

`interface`关键字使抽象的概念更向前迈进了一步。`abstract`关键字允许人们在类中创建一个或多个没有任何定义的方法 —— 提供了接口部分，但是没有提供任何相应的具体实现，这些实现是由此类的继承者创建的。`interface`这个关键字产生一个完全抽象的类，它根本就没有提供任何具有实现。它允许创建者确定方法名、参数列表和返回类型，但是没有任何方法体。接口只提供形式，而未提供任何具体实现。

一个接口表示：“所有实现了该特定接口的类看起来都像这样”。因此，任何使用某特定接口的代码都知道可以调用该接口的哪些方法，而且仅需要知道这些。因此，接口被用来建立类与类之间的`协议`。

但是，`interface`不仅仅时一个极度抽象的类，因为它允许人们通过创建一个能够被向上转型为多种基类的类型，来实现某种类似多重继变种的特性。

要想创建一个接口，需要用`interface`关键字来替代class关键字。就像类一样，可以在`interface`关键字前面添加`public`关键字（但仅限于该接口在与其同名的文件中被定义）。如果不添加`public`关键字，则它只是有包访问权限，这样它就只能在同一个包内可用。接口也可以包含域，但是这些域隐式地时`static`和`final`的。

要让一个类遵循某个特定接口（或者是一组接口），需要使用`implements`关键字，它表示：“`interface`只是它的外貌，但是现在我要声明它是如何工作的。”除此之外，它看起来还很像继承。“乐器”示例的图说明了这一点。

<img src="./images/9/2.png" alt="" align=center />

## 9.3 完全解藕

## 9.4 Java中的多重继承

## 9.5 通过继承来扩展接口

### 9.5.1 组合接口时的名字冲突

## 9.6 适配接口

## 9.7 接口中的域

### 9.7.1 初始化接口中的域

## 9.8 嵌套接口

## 9.9 接口与工厂

## 9.10 总结

# 第8章 多态

- [第8章 多态](#第8章-多态)
  - [8.1 再论向上转型](#81-再论向上转型)
    - [8.1.1 忘记对象类型](#811-忘记对象类型)
  - [8.2 转机](#82-转机)
    - [8.2.1 方法调用绑定](#821-方法调用绑定)
    - [8.2.2 产生正确的行为](#822-产生正确的行为)
    - [8.2.3 可扩展性](#823-可扩展性)
    - [8.2.4 缺陷：“覆盖”私有方法](#824-缺陷覆盖私有方法)
    - [8.2.5 缺陷：域或静态方法](#825-缺陷域或静态方法)
  - [8.3 构造方法和多态](#83-构造方法和多态)
    - [8.3.1 构造器的调用顺序](#831-构造器的调用顺序)
    - [8.3.2 继承与清理](#832-继承与清理)
    - [8.3.3 构造器内部的多态方法的行为](#833-构造器内部的多态方法的行为)
  - [8.4 协变返回类型](#84-协变返回类型)
  - [8.5 用继承进行设计](#85-用继承进行设计)
    - [8.5.1 纯继承与扩展](#851-纯继承与扩展)
    - [8.5.2 向下转型与运行时类型识别](#852-向下转型与运行时类型识别)
  - [8.6 总结](#86-总结)

---

**面向对象程序设计语言的三种基本特征：`抽象`、`继承`和`多态`。**

多态通过分离做什么和怎么做，从另一角度将接口和实现分类开来。多态不但能够改善代码的组织结构和可读性，还能创建*可扩展*的程序 —— 即无论在项目最初创建时还是在需要添加新功能时都可以“生长”。

“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“**私有化**”把接口和实现分离开来。而多态的作用则是消除类型之间的耦合关系。

## 8.1 再论向上转型

在第7章中我们已经知道，对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。而这种把对某个对象的引用视为对其基类型的引用的做法称为`向上转型` —— 因为在继承树的画法中，基类是放置在上方的。

### 8.1.1 忘记对象类型

示例：

``` java
/** 曲调 */
public enum Note {
    MIDDLE_C, C_SHARP, B_FLAT;
}
/** 乐器 */
public class Instrument {
    public void play(Note n) {
        System.out.println("Instrument.play()");
    }
}
/** 某种乐器 */
public class Wind extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Wind.play() " + n);
    }
}
/** 音乐 */
public class Music {
    public static void tune(Instrument i){
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Wind wind = new Wind();
        tune(wind);
    }
}
```

`Music.java` 看起来似乎有些奇怪。为什么所有人都故意*忘记*对象的类型呢？在进行向上转型时，就会产生这种情况；并且如果让 `tune()` 方法直接接受一个 `Wind` 引用作为自己的参数，似乎会更为直观。但这样引发的一个重要问题是：*如果那样做，就需要为系统内 `Instrument` 的每一种类型都编写一个新的 `tune()` 方法*。

如果我们只写这样一个简单方法，它仅接收基类作为参数，而不是那些特殊的导出类。这样做情况会变得更好吗？也就是说，如果我们不管导出类的存在，编写的代码只是与基类打交道，会不会更好呢？这正是多态所允许的。

## 8.2 转机

观察上面示例中的 `tune()` 方法，它接受一个 `Instrument` 引用。那么在这种情况下，编译器怎样才能知道这个 `Instrument` 引用指向的是 `Wind` 对象，而不是 `Brass` 对象或者 `Stringed` 对象呢？实际上，编译器无法得知。为了深入理解这个问题，有必要研究一下 `绑定` 这个话题。

### 8.2.1 方法调用绑定

将一个方法调用同一个方法主体关联起来被称为`绑定`。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做`前期绑定`。

上述程序之所以令人迷惑，主要是因为前期绑定。因为，当编译器只有一个 `Instrument` 引用时，它无法知道究竟调用哪个方法才对。解决的办法就是`后期绑定`，它的含义就是在运行时根据对象的类型进行绑定。

`后期绑定`也叫做`动态绑定`或`运行时绑定`。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法。

Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。这意味着通常情况下，我们不必判定是否应该进行后期绑定 —— 它会自动发生。

### 8.2.2 产生正确的行为

一旦知道Java中所有方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与基类打交道的程序代码了，并且这些代码对所有的导出类都可以正确运行。或者换一种说法，发送消息给某个对象，让该对象去判定该做什么事。

面向对象程序设计中，有一个经典的例子就是“几何图形”。有一个基类Shape，以及多个导出类 —— 如Cirele、Square、Triangle等。这个例子之所以好用，是因为我们可以说“圆是一种几何形状”，这种说法很容易被理解。

这个“几何图形”案例就是为了让大家理解：*在编译时，编译器不需要获得任何特殊信息就能进行正确的调用。对draw()方法的所有调用都是通过动态绑定进行的*。

### 8.2.3 可扩展性

回到“乐器”（Instrument）示例。由于有多态机制，我们可根据自己的需求对系统添加任意多的新类型，而不需要更改tune()方法。在一个设计良好的OOP程序中，大多数或者所有方法都会遵循tune()的模型，而且只与基类接口通信。这样的程序是*可扩展*的，因为可以通用的基类继承出新的数据类型，从而新添一些功能。那些操纵基类接口的方法不需要任何改动就可以引用于新类。

tune()方法完全可以忽略它周围代码所发生的全部变化，依旧正常运行。这正是我们期望多态所具有的特性。我们所做的代码修改，不会对程序中其他不应收到影响的部分产生破坏。换句话说，多态是一项让程序员“将改变事物于未变的事物分离开来”的重要技术。

### 8.2.4 缺陷：“覆盖”私有方法

``` java
public class PrivateOverride {
    private void f(){
        System.out.println("private f()");
    }
    public static void main(String[] args) {
        PrivateOverride po = new Derived();
        po.f();
    }
}

class Derived extends PrivateOverride {
    public void f(){
        System.out.println("public f()");
    }
}

 /* Output : 
private f()
 */
```

我们所期望的输出是`public f()`，但是由于private方法被自动认为是final方法，而且对导出类是屏蔽的。因此，在这种情况下，Derived类中的f()方法就是一个全新的方法；既然基类中的f()方法在子类Derived中不可见，因此甚至也不能被重载。

结论就是：只有非private方法才可以被覆盖；但是还需要密切关注覆盖private方法的现象，这时虽然编译器不会报错，但是也不会按照我们所期望的来执行。确切地说，在导出类中对于基类中的private方法，最好采取不同的名字。

### 8.2.5 缺陷：域或静态方法

## 8.3 构造方法和多态

### 8.3.1 构造器的调用顺序

### 8.3.2 继承与清理

### 8.3.3 构造器内部的多态方法的行为

## 8.4 协变返回类型

## 8.5 用继承进行设计

### 8.5.1 纯继承与扩展

### 8.5.2 向下转型与运行时类型识别

## 8.6 总结
# 第8章 多态

- [第8章 多态](#第8章-多态)
  - [8.1 再论向上转型](#81-再论向上转型)
    - [8.1.1 忘记对象类型](#811-忘记对象类型)
  - [8.2 转机](#82-转机)
    - [8.2.1 方法调用绑定](#821-方法调用绑定)
    - [8.2.2 产生正确的行为](#822-产生正确的行为)
    - [8.2.3 可扩展性](#823-可扩展性)
    - [8.2.4 缺陷：“覆盖”私有方法](#824-缺陷覆盖私有方法)
    - [8.2.5 缺陷：域或静态方法](#825-缺陷域或静态方法)
  - [8.3 构造方法和多态](#83-构造方法和多态)
    - [8.3.1 构造器的调用顺序](#831-构造器的调用顺序)
    - [8.3.2 继承与清理](#832-继承与清理)
    - [8.3.3 构造器内部的多态方法的行为](#833-构造器内部的多态方法的行为)
  - [8.4 协变返回类型](#84-协变返回类型)
  - [8.5 用继承进行设计](#85-用继承进行设计)
    - [8.5.1 纯继承与扩展](#851-纯继承与扩展)
    - [8.5.2 向下转型与运行时类型识别](#852-向下转型与运行时类型识别)
  - [8.6 总结](#86-总结)

---

**面向对象程序设计语言的三种基本特征：`抽象`、`继承`和`多态`。**

多态通过分离做什么和怎么做，从另一角度将接口和实现分类开来。多态不但能够改善代码的组织结构和可读性，还能创建*可扩展*的程序 —— 即无论在项目最初创建时还是在需要添加新功能时都可以“生长”。

“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“**私有化**”把接口和实现分离开来。而多态的作用则是消除类型之间的耦合关系。

## 8.1 再论向上转型

在第7章中我们已经知道，对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。而这种把对某个对象的引用视为对其基类型的引用的做法称为`向上转型` —— 因为在继承树的画法中，基类是放置在上方的。

### 8.1.1 忘记对象类型

示例：

``` java
/** 曲调 */
public enum Note {
    MIDDLE_C, C_SHARP, B_FLAT;
}
/** 乐器 */
public class Instrument {
    public void play(Note n) {
        System.out.println("Instrument.play()");
    }
}
/** 某种乐器 */
public class Wind extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Wind.play() " + n);
    }
}
/** 音乐 */
public class Music {
    public static void tune(Instrument i){
        i.play(Note.MIDDLE_C);
    }

    public static void main(String[] args) {
        Wind wind = new Wind();
        tune(wind);
    }
}
```

`Music.java` 看起来似乎有些奇怪。为什么所有人都故意*忘记*对象的类型呢？在进行向上转型时，就会产生这种情况；并且如果让 `tune()` 方法直接接受一个 `Wind` 引用作为自己的参数，似乎会更为直观。但这样引发的一个重要问题是：*如果那样做，就需要为系统内 `Instrument` 的每一种类型都编写一个新的 `tune()` 方法*。

如果我们只写这样一个简单方法，它仅接收基类作为参数，而不是那些特殊的导出类。这样做情况会变得更好吗？也就是说，如果我们不管导出类的存在，编写的代码只是与基类打交道，会不会更好呢？这正是多态所允许的。

## 8.2 转机

观察上面示例中的 `tune()` 方法，它接受一个 `Instrument` 引用。那么在这种情况下，编译器怎样才能知道这个 `Instrument` 引用指向的是 `Wind` 对象，而不是 `Brass` 对象或者 `Stringed` 对象呢？实际上，编译器无法得知。为了深入理解这个问题，有必要研究一下 `绑定` 这个话题。

### 8.2.1 方法调用绑定

将一个方法调用同一个方法主体关联起来被称为`绑定`。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做`前期绑定`。

上述程序之所以令人迷惑，主要是因为前期绑定。因为，当编译器只有一个 `Instrument` 引用时，它无法知道究竟调用哪个方法才对。解决的办法就是`后期绑定`，它的含义就是在运行时根据对象的类型进行绑定。

`后期绑定`也叫做`动态绑定`或`运行时绑定`。如果一种语言想实现后期绑定，就必须具有某种机制，以便在运行时能判断对象的类型，从而调用恰当的方法。

Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。这意味着通常情况下，我们不必判定是否应该进行后期绑定 —— 它会自动发生。

### 8.2.2 产生正确的行为

### 8.2.3 可扩展性

### 8.2.4 缺陷：“覆盖”私有方法

### 8.2.5 缺陷：域或静态方法

## 8.3 构造方法和多态

### 8.3.1 构造器的调用顺序

### 8.3.2 继承与清理

### 8.3.3 构造器内部的多态方法的行为

## 8.4 协变返回类型

## 8.5 用继承进行设计

### 8.5.1 纯继承与扩展

### 8.5.2 向下转型与运行时类型识别

## 8.6 总结
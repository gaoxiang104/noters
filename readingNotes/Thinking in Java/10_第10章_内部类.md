# 第10章 内部类

- [第10章 内部类](#第10章-内部类)
  - [10.1 创建内部类](#101-创建内部类)
  - [10.2 链接到外部类](#102-链接到外部类)
  - [10.3 使用.this与.new](#103-使用this与new)
  - [10.4 内部类与向上转型](#104-内部类与向上转型)
  - [10.5 在方法和作用域内到内部类](#105-在方法和作用域内到内部类)
  - [10.6 匿名内部类](#106-匿名内部类)
    - [10.61 再访工厂方法](#1061-再访工厂方法)
  - [10.7 嵌套类](#107-嵌套类)
    - [10.7.1 接口内部的类](#1071-接口内部的类)
    - [17.7.2 从多层嵌套类中访问外部类的成员](#1772-从多层嵌套类中访问外部类的成员)
  - [10.8 为什么需要内部类](#108-为什么需要内部类)
    - [10.8.1 闭包与回调](#1081-闭包与回调)
    - [10.8.2 内部类与控制框架](#1082-内部类与控制框架)
  - [10.9 内部类的继承](#109-内部类的继承)
  - [10.10 内部类可以被覆盖吗](#1010-内部类可以被覆盖吗)
  - [10.11 局部内部类](#1011-局部内部类)
  - [10.12 内部类标识符](#1012-内部类标识符)
  - [10.13 总结](#1013-总结)

> 可以将一个类的定义放在另一个类的定义内部，这就是内部类。
>
> 内部类是一种非常有用的特性，因为它允许你把一下逻辑相关的类组织在一起，并控制位于内部的类的可见性。然而必需要了解，内部类与组合是完全不同的概念，这一点很重要。
> 
> 在最初，内部类看起来就像是一种代码隐藏机制：将类置于其他类的内部。但是，你将会了解到，内部类远不止如此，它了解外围类，并能与之通信；而且你用内部类写出的代码更加优雅而清晰，尽管并不总是这样。

## 10.1 创建内部类

创建内部类的方式就如同你想的一样 —— 把类的定义置于外围类的里面：

``` java
public class Parcel1 { // 包裹
    class Contents { // 内容
        private int i = 11;
        public int value() { return i; }
    }

    class Destination { // 目的地
        private String label;
        public Destination(String label) { this.label = label; }

        String readLabel() { return label; }
    }

    public void ship(String dest) { // 运送
        Contents c = new Contents();
        Destination d = new Destination(dest);
        System.out.println(d.readLabel());
    }

    public static void main(String[] args) {
        Parcel1 p = new Parcel1();
        p.ship("Tasmania");
    }
}
```

当我们在`ship()`方法里面使用内部类的时候，与使用普通类没什么不同。在这里，实际的区别只是内部类的名字是嵌套在`Parcel1`里面的。

如果想从外部类的非静态方法之外的任意位置创建某个内部类的对象，那么必须像在`main()`方法中那样，具体地指明这个对象的类型：***OuterClassName.InnerClassName*** 。 如下例：

``` java
public class Parcel2 {
    class Contents { // 内容
        private int i = 11;
        public int value() { return i; }
    }

    class Destination { // 目的地
        private String label;
        public Destination(String label) { this.label = label; }
        String readLabel() { return label; }
    }

    public Destination to(String s) {
        return new Destination(s);
    }

    public Contents contents() {
        return new Contents();
    }

    public void ship(String dest) {
        Contents c = contents();
        Destination d = to(dest);
        System.out.println(d.readLabel());
    }

    public static void main(String[] args) {
        Parcel2 p = new Parcel2();
        p.ship("Tasmania");
        // Defining references to inner classes;
        Parcel2 q = new Parcel2();
        Parcel2.Contents c = q.contents();
        Parcel2.Destination d = q.to("Borneo");
    }
}
```

## 10.2 链接到外部类

到目前为止，内部类似乎还只有一种名字隐藏和组织代码的模式。这些是很有用，但还不是最引人注目的，它还有其他的用途。当生成一个内部类的对象时，此对象与制造它的外围对象（enclosing object）之间就有了一种联系，所以它能访问其外部对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外部类的所有元素的访问权限。下面的例子说明了这一点：

``` java
// : innerclasses/Sequence.java

interface Selector { // 迭代器
    boolean end();
    Object current();
    void next();
}

public class Sequence {
    private Object[] items;
    private int next = 0;

    public Sequence(int size) { items = new Object[size]; }

    public void add(Object x) {
        if (next < items.length) { items[next++] = x; }
    }

    private class SequenceSelector implements Selector {
        private int i = 0;
        @Override
        public boolean end() { return i == items.length; }
        @Override
        public Object current() { return items[i]; }
        @Override
        public void next() { if (i < items.length) i++; }
    }

    public Selector selector(){
        return new SequenceSelector();
    }

    public static void main(String[] args) {
        Sequence sequence = new Sequence(10);
        for (int i = 0; i < 10; i++) { sequence.add(Integer.toString(i)); }
        Selector selector = sequence.selector();
        while (!selector.end()){
            System.out.print(selector.current() + "  ");
            selector.next();
        }
    }
}
/* output :
0  1  2  3  4  5  6  7  8  9
*/
```

`Sequence`类只是一个固定大小的`Object`的数组，以类的形式包装了起来。可以调用`add()`在序列末增加新的`Object`（只要还有空间）。要获取`Sequence`中的每一个对象，可以使用`Selector`接口。这是“迭代器”设计模式的一个例子。`Selector`允许你检查序列是否末尾了（`end()`），访问当前对象(`current()`)，以及移到序列中的下一个对象(`next()`)。

最初看到`SequenceSelector`，可能会觉得它只不过是另一个内部类罢了。但是仔细观察它，注意方法`end()`、`current()`、`next()`都用澳了`objects`，这是一个引用，它并不是`SequenceSelector`的一部分，而是外围类中的一个`private`字段。然而内部类可以访问其他外围类的方法和字段，就像自己拥有它们似的，这带来了很大的方便，就如前面的例子所示。

> 所以内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向哪个外围类对象的引用。然后，在你访问此外围类的成员时，就是用哪个引用来选择外围类的成员。幸运的是，编译器会帮助你处理所有的细节，但你现在可以看到：内部类的对象只能在与其外围类的对象相关联的情况下能被创建（就像你应该看到的，在内部类是非static时）。构建内部类对象时，需要一个指向其外部类对象的引用，如果编译器访问不到这个引用就会报错。不过绝大多数时候都无需程序员操心。

## 10.3 使用.this与.new

如果你需要生成对外部类对象的引用，可以使用外部类的名字后面紧跟`圆点和this`。这样产生的引用自动地具有正确的类型，这一点再编译期就被知晓并受到检查，因此咩有任何运行时开销。下面的示例展示了如何使用`.this`:

``` java

public class DotThis {
    void f() { System.out.println("DotThis.f()"); }
    public class Inner {
        public DotThis outer() {
            return DotThis.this;
        }
    }
    public Inner inner() { return new Inner(); }
    public static void main(String[] args) {
        DotThis dt = new DotThis();
        DotThis.Inner dti = dt.inner();
        dti.outer().f();
    }
}
/* output : 
DotThis.f()
 */
```

有时你可能想要告知某些其他对象，去创建其某个内部类的对象。要实现此目的，你必须在new表达式中提供对其他外部类对象的引用，这是需要使用`.new`语法，就像下面这样：

``` java
public class DotNew {
    public class Inner{}
    public static void main(String[] args) {
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();
    }
}
```

要想直接创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字DotNew，而是必须使用外部类的对象来创建该内部类对象，就像在上面的程序中所看到的那样。这也解决了内部类名字作用域的问题，因此你不必声明（也不能声明）`dn.new DontNew.Inner()`

> 注意：在拥有外部对象之前是不可能创建内部类对象的。这是因为内部类对象会暗暗地连接到创建它的外部对象上。但是，如果你创建的是嵌套类（静态内部类），那么它就不需要对外部类对象的引用。

## 10.4 内部类与向上转型

当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。（从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。）这是因为此内部类 —— 某个接口的实现 —— 能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。

``` java
// innerclasses.Destination.java
public interface Destination { String readLabel(); }

// innerclasses/Contents.java
public interface Contents { int value(); }

// innerclasses/Parcel4.java
public class Parcel4 {
    private class PContents implements Contents {
        private int i;
        @Override
        public int value() { return i; }
    }
    protected class PDestination implements Destination {
        String label;
        private PDestination(String label) { this.label = label; }
        @Override
        public String readLabel() { return label; }
    }
    public Destination destination(String s) { return new PDestination(s); }
    public Contents contents() { return new PContents(); }

    public static void main(String[] args) {
        Parcel4 parcel4 = new Parcel4();
        Contents c = parcel4.contents();
        Destination d = parcel4.destination("Tasmania");
    }
}

```

`Parcel4`中增加了一些新东西：内部类`PContents`是`private`。`PDestination`是`protected`，构造器是`private`的。这意味着，如果客户端程序员想了解或访问这些成员，那是要受到限制的。*通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。*

## 10.5 在方法和作用域内到内部类

## 10.6 匿名内部类

### 10.61 再访工厂方法

## 10.7 嵌套类

### 10.7.1 接口内部的类

### 17.7.2 从多层嵌套类中访问外部类的成员

## 10.8 为什么需要内部类

### 10.8.1 闭包与回调

### 10.8.2 内部类与控制框架

## 10.9 内部类的继承

## 10.10 内部类可以被覆盖吗

## 10.11 局部内部类

## 10.12 内部类标识符

## 10.13 总结
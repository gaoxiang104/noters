# 第7章 复用类

复用代码是Java众多引入注目第功能之一。复用代码带方法有两种：

1. 第一种方法非常直观：只需要在新的类中产生现有类的对象。由于新的类是由现有类的对象组成，所以这种方法称为`组合`；
2. 第二种方法则更细致一些，它按照现有类的类型来创建新类。无需改变现有类的形式，采用现有类的形式并在其中添加新代码。这种神奇的方式称为`继承`; 

## 7.1 组合语法

只需将对象引用置于新类中即可。

## 7.2 继承语法

继承是所有OOP语言和Java语言不可缺少都组成部分。

当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是在隐式地从Java的 `标准根类Object` 进行继承。

继承的声明：通过在类主体的左花括号之前，书写 `extends` 关键字，加基类名称。

```java
class Sub extends Father{ ... }
```

### 7.2.1 初始化基类

当创建一个导出类当对象时，该对象包含了一个基类当子对象。这个子对象与你用基类直接创建的对象是一样的。二者的区别在于，后者来自于外部，而基类的子对象被包装在导出类对象内部。

```java

class Art {
    public Art() {System.out.println("Art constructor");}
}
class Drawing extends Art {
    public Drawing() {System.out.println("Drawing constructor");}
}
public class Cartoon extends Drawing {
    public Cartoon() {System.out.println("Cartoon constructor");}
    public static void main(String[] args) {
        Cartoon x = new Cartoon();
    }
} /* Outout:
Art constructor
Drawing constructor
Cartoon constructor
*/

```

### 7.2.2 带参数的构造器

类含有默认的构造器，即构造器都不带参数。编译器可以轻松地调用它们是因为不必考虑要传递什么样的参数的问题。但是，如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就*必须用关键字 `super` 显示地编写调用基类构造器的语句，而且必须在导出类构造器中要做的第一件事情（即在构造方法第一行声明）*；

## 7.3 代理

第三种关系称为代理，Java并没有提供对它对直接支持。这是继承与组合之间对中庸之道，因为我们将一个成员对象置于所要构造对类中（就像组合），但与此同时我们在新类中暴露了该成员对象但所有方法（就像继承）。 参考：练习11 案例；

## 7.4 结合使用组合和继承

同时使用组合和继承是很常见的事。

### 7.4.1 确保正确清理

`try` 和 `finally` 关键字。关键字 `try` 表示，下面的块（用一组大括号括起来的范围）是所谓的 `保护区` （guarded region），这意味着它需要被特殊处理。其中一项特殊处理就是无论try块是怎么样退出的，*保护区后的finally子句中的代码总是要被执行的*。

### 7.4.2 名称屏蔽

*如果Java的基类拥有某个已被多次重载的方法名称，那么在导出类中重新定义该方法名称并****不会屏蔽其中的任何版本***。因此，无论是在该层或者它的基类中对方法进行定义，重载机制都可以正常工作。

Java SE5新增类 @Override注解，它并不是关键字，但是可以把它当作关键字使用，当你想要覆写某个方法时，可以选择添加这个注解，在你不留心重载而并非覆写了该方法时，编译器就会生成一条错误信息。

总结： `@Override` 就是声明此方法时覆写方法，并非重载方法。

## 7.5 在组合与继承之间选择

组合和继承都允许在新都类中放置子对象，组合是显式地这样做，二继承则是隐式地做。

组合技术通常用于想在新类中使用现有类地功能而非它地接口这种情形。

在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。

例如：用一个“交通工具”对象来构成一部“车子”是毫无意义的，因为“车子”并不包含“交通工具”，它仅是一种交通工具（is-a关系）。**“is-a”（是一个）的关系是用继承来表达的，而“has-a”（有一个）的关系则是用组合来表达的**

## 7.6 protected关键字

在理想世纪中，仅靠关键字private就已经足够了。但在实际项目中，经常会想要将某些事物尽可能对这个世界隐藏起来，但仍然允许导出类的成员访问它们。关键字 `protected` 就是起这个作用的。它指明“就类用户而言，这是private的，但是对于任何继承于此类的导出类或其他任何位于同一个包内的类来说，它却是可以访问的。”（protected页提供类包内访问权限。）

尽管可以创建protected域，但是最好的方式还是将域保持为private；应当一直保留“更变改底层实现”的权利。然后通过protected方法来控制类的继承者的访问权限。

## 7.7 向上转型

将 `导出类的引用转换为基类的引用的动作` ，称之为 `向上转型` 。

### 7.7.1 为什么称为向上转型

由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型。

由于向上转型是从一个较专用类型向通用类型转换，所以总是安全的。也就是说，导出类是基类的一个超级。它可能比基类含有更多的方法，但它必须至少具备基类中含有的方法。

在向上转型的过程中，类接口中唯一可能发生的事情是丢失方法，而不是获取它们。这就是为什么编译器在“未曾明确表示转型”或“未曾指定特殊标记”的情况下，仍然允许向上转型的原因。

### 7.7.2 再轮组合和继承

继承其实不太常用。而且要慎用。到底是该用组合还是继承，一个最清晰的判断办法就是问一问自己是否需要要从新类向基类进行向上转型。如果必须向上转型，则继承是必要；但如果不需要，则应当好好考虑自己是否需要继承。

## 7.8 final关键字

final通常指的是“这是无法改变的。”不想做改变可能出于两种理由：“设计”或“效率”。

可能用到final的三种情况：数据、方法和类。

### 7.8.1 数据

许多编程语言都有某种方法，来向编译器告知一块数据是否恒定不变的。有时数据的恒定不变是很有用的，比如：

1. 一个永不改变的编译时常量。
2. 一个在运行时被初始化的值，而你不希望它被改变。

对于编译期常量这种情况，编译器可以将该常量值带入任何可能用到它的计算式中，也就是说，可以在编译时执行计算式，这减轻来一些运行时的负担。

常量是基本类型，以关键字final表示，在常量定义的时候，必须对其进行赋值。

一个既是static又是final的域只占一段不能改变的存储空间。

*当对对象引用而不是基本类型运用final时，其含义会有一点令人迷惑。对于基本类型，final使数值恒定不变；而用于对象引用，final使引用恒定不变。* 一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。然而，对象其自身却是可以被修改的，Java并未提供使任何对象恒定不变的途径。这一限制同样适用数组。

**常量书写规范：** 根据惯例，既是static又是final的域将用大写表示，并使用下划线分隔各个单词。

**空白final：** Java允许生产“空白final”，所谓空白final是指被声明为final但又未给定初始值的域。无论什么情况，编译器都确保空白final在使用前初始化。***（必须在构造器中进行初始化，如果有多个，那么每一个构造器中都必须进行初始化，否则会编译报错）***

**final参数：** Java允许在参数列表中以声明都方式将参数指明为final。***这意味着你无法在方法中更改参数引用所指都对象;如果final参数为基本类型时，此参数只可读性，不能被修改；***。

# 第8章 多态

**在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征**

多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。多态不但能够改善代码的组织结构和可读性，还能够创建*可扩展的*程序——即无论在项目最初创建时还是在需要添加新功能时都可以“生长”的程序

“封装”通过合并特征和行为来创建新的数据类型。“实现隐藏”则通过将细节“**私有化**”把接口和实现分离开来。这种类型的组织机制对那些拥有过程化程序设计背景的人来说，更容易理解。而多态的作用则是消除类型之间的耦合关系。向上转型这种能力极为重要，因为它允许将多种类型（从同一基类导出的）视为同一类型来处理，而同一份代码也就是可以毫无差别地运行在这些不同类型之上。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是同一基类导出而来的。这种区别是根据方法行为的不同而表示出来的，虽然这些方法都可以通过同一个基类来调用。

## 8.1 再论向上转型

在第7章中已经知道，对象既可以作为它自己本身的类型使用，也可以作为它的基类类型使用。而这种把对某个对象的引用视为基类类型的引用的做法被称为 `向上转型` （因为在继承树的画法中，基类是放置在上方）。

具体看下面有关乐器的例子：

```java

// Note.java
package pers.xgo.chapter8.demos.music;
/** 曲调  */
public enum Note {
    MIDDLE_C, C_SHARP, B_FLAT;
}

// Instrument.java
package pers.xgo.chapter8.demos.music;
/** 乐器 */
public class Instrument {
    public void play(Note n) {
        System.out.println("Instrument.play()");
    }
}

// Wind.java
package pers.xgo.chapter8.demos.music;
/** 管乐器 */
public class Wind extends Instrument {
    @Override
    public void play(Note n) {
        System.out.println("Wind.play() " + n);
    }
}

// Music.java
package pers.xgo.chapter8.demos.music;
/** 音乐 */
public class Music {
    public static void tune(Instrument i){
        i.play(Note.MIDDLE_C);
    }
    public static void main(String[] args) {
        Wind wind = new Wind();
        tune(wind);
    }
}
```

Music.tune()方法接受一个Instrument引用，同时也接受任何导出自Instrument的类。在main()方法中，当一个Wind引用专递到tune()方法时，就会出现这种情况，而不需要任何类型转换。这样做是允许的，因为Wind从Instrument继承而来，所以Instrument的接口必定存在于Wind中。从Wind向上转型到Instrument可能会“缩小”接口，但不会比Instrument但全部接口更窄。

### 8.1.1 忘记对象类型

Music.java看起来似乎有些奇怪。为什么所有人都故意忘记对象都类型呢？在进行向上转型时，就会产生这种情况；并且如果让tune()方法直接接受一个Wind引用作为自己都参数，似乎会更为直观。但这样引发的一个重要问题是：*如果这样做，就需要为系统内Instrument的每种类型都编写一个新都tune()方法*。

## 8.2 转机

### 8.2.1 方法调用绑定

将一个方法调用同一个方法主体关联起来被称作绑定。若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现），叫做`前期绑定`。它是面向过程的语言中不需要选择就默认的绑定方式。

上述程序之所以令人迷惑，主要是因为前期绑定。因为，编译器只有一个Instrument引用时，它午饭知道究竟调用哪个方法才对。

解决办法就是`后期绑定`，它的含义就是在运行时根据对象的类型进行绑定。后期绑定也叫`动态绑定`或`运行时绑定`。

Java中除了static方法和final方法（private方法属于final方法）之外，其他所有的方法都是后期绑定。

### 8.2.2 产生正确的行为

一旦知道Java中所有方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与基类打交道的程序代码了，并且这些代码对所有对导出类都可以正确运行。*或者换一种说法，发消息给某个对象，让该对象去判断应该做什么事情*。

在“几何图形”这个例子中，有一个基类shape，以及多个导出类 —— 如 Circle、Square、Triangle等。这个例子之所以好用，是因为我们可以说“圆是一种几何图形”，这种说法很容易被理解。

### 8.2.3 可扩展性
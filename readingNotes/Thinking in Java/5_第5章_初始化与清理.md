# 第5章 初始化与清理

## 5.1 用构造器确保初始化

构造器的作用：通过提供构造器，类的设计者可确保每个对象都会得到初始化。

如何定义一个构造器：

* 构造器的名称必须与类名完全相同；
* 构造器没有返回值；

无参构造器：不接受任务参数的构造器称为默认构造器，也叫无参构造器；

有参构造器：构造器也能带有形式参数，有了构造器形式参数，就可以在初始化对象时提供实际参数。

## 5.2 方法重载

什么是方法重载？方法名称相同而形式参数不同的方法，称之为`'方法重载'`。

区分重载方法：每一个重载方法都必须有独一无二的参数列表。甚至参数顺序的不同也足以区分两个方法。

*涉及基本类型的重载：略过，实际生产中不会用到*

### 5.2.3 以返回值区分重载方法

比如下面两个方法，虽然它们有相同的名字和形式参数：

```java
void f(){}
int f(){ return 1; }
```

如果像下面这样调用方法：`f()`，此时Java就不能判断该调用哪个方法`f()`。

因此根据方法的返回值来区分重载方法是行不通的。

## 5.3 默认构造器

默认构造器（又名“无参”构造器）是没有形式参数的——它的作用是创建一个“默认对象”。如果类中没有写构造器，则编译器会自动创建一个默认构造器。但是已经定义类一个构造器（无论是否有参），编译器就不会帮你自动创建默认构造器。

## 5.4 this关键字

只有当需要明确指出当前对象的引用时，才需要使用this关键字。

例：

```java
public class Leaf {
    int i = 0;
    Leaf increment() {
        i++;
        return this;
    }
    void print() {
        System.out.println("i = " + i);
    }
    public static void main(String[] args) {
        new Leaf().increment().increment().increment().print();
    }
}
```

### 5.4.1 在构造器中调用构造器

通常写`this`的时候，都是指“这个对象”或者“当前对象”，而且它本身表示对当前对象的引用。

在构造器中，如果为this添加类参数列表，那么就有类不同的含义。这将产生对符合此参数列表的某个构造器的明确调用。

例：

```java
public class Flower {
    int petalCount = 0;
    String s = "initial value";

    Flower(int petalCount) {
        this.petalCount = petalCount;
        print("Constructor w/ int arg only, petalCount = " + this.petalCount);
    }

    Flower(String s) {
        this.s = s;
        print("Constructor w/ string arg only, s = " + this.s);
    }

    Flower(String s, int petalCount) {
        this(petalCount);
        //! this(s); // Another use of "this"
        this.s = s;
        print("String & int args");
    }

    Flower() {
        this("h1", 7);
        print("default constructor (no args)");
    }

    void printPetalCount() {
        //!  this(11); // Not inside non-constructor
        print("petalCount = " + petalCount + ", s = " + s);
    }

    void print(String str) {
        System.out.println(str);
    }

    public static void main(String[] args) {
        Flower x = new Flower();
        x.printPetalCount();
    }
}
/* Output:
Constructor w/ int arg only, petalCount = 7
String & int args
default constructor (no args)
petalCount = 7, s = h1
 */
```

尽管可以用this调用一个构造器，却不能调用两个。此外，必须将构造器调用置最起始出，否则编译器会报错。

this的另一种用法。由于参数s的名称和数据成员s的名称相同，所以会产生歧义。使用this.s来代表数据成员就能解决这个问题。

### 5.4.2 static的含义

static方法就是没有this的方法。在static方法的内部不能调用非静态方法，反过来倒是可以。

在没有创建任何对象的前提下，仅仅通过类名来调用static方法。这实际上正是static方法的主要用途。

## 5.5 清理：终结处理和垃圾回收

Java有垃圾回收器负责回收无用对象占据的内存资源。

finalize()方法：一旦垃圾回收器准备好释放对象占用的存储空间，将首先调用其finalize()方法，并且在下一次垃圾回收动作发生时，才会真正回收占用的内存。

理解：

* 垃圾回收器准备好释放，和真正释放 是两个动作。

### 5.5.1 finalize()的用途何在

垃圾回收只与内存有关。

使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收器有关的任何行为来说（尤其是finalize()方法），它们也必须通内存及其回收有关。

finalize()方法的用途之一：`在finalize()方法中调用“本地方法”释放内存`。

本地方法是一种在Java中调用非Java代码的方式，比如：C和C++语言。

### 5.5.3 终结条件

例如：要是对象代表了一个打开的文件，在对象被回收前程序员应该关闭这个文件。只要对象中存在没有被适当清理的部分，程序就存在很隐晦的缺陷。finalize()可以用来最终发现这种情况——尽管它并不总是会被调用。


